// use std::str::FromStr;
//use std::collections::HashMap;
// use crate::ast_utils::Syntax;
use crate::parser_utils::{dec_node_into_exp, get_one};
use crate::ast::{Node, NodeData, Source, Id, Id_, ToId, Pat, Pat_, Exp, Exp_, ExpField, Function, ObjSort, Type, Type_, TypeField, TypeField_, TypeBind, TypeBind_, TypeTag, TypeTag_, ValTypeField, TypePath, TypePath_, PrimType, Literal, Case, Cases, Decs, Dec, Dec_, UnOp, BinOp, RelOp, Delim, Mut, SortPat, Sugar, Vis, Vis_, Stab, Stab_, DecField, DecField_, DecFields};
use crate::value::PrimFunction;
// use crate::lexer_types::Token;
use line_col::LineColLookup;
use im_rc::vector;
use crate::shared::{Share};

grammar(lookup: &LineColLookup<'input>);


// Defining operator precedence:

// The compiler's parser generator is able to accept precedence
// declarations to disambiguate the grammar.

// ```
// %nonassoc RETURN_NO_ARG IF_NO_ELSE LOOP_NO_WHILE
// %nonassoc ELSE WHILE

// %left COLON
// %left OR
// %left AND
// %nonassoc EQOP NEQOP LEOP LTOP GTOP GEOP
// %left ADDOP SUBOP WRAPADDOP WRAPSUBOP HASH
// %left MULOP WRAPMULOP DIVOP MODOP
// %left OROP
// %left ANDOP
// %left XOROP
// %nonassoc SHLOP SHROP ROTLOP ROTROP
// %left POWOP WRAPPOWOP
// ```

// Here, in LALRPOP, we do not have that affordance.  So, we must encode
// precedence relationships manually, as manually-stratified productions.

// We do so by creating a production for each line of the declarations above.
// Productions refer to later ones, but not earlier ones, except in special cases.

// These constructions are effectively each an "expansion" of one of
// the declarative precedence lines.



// --- Helper Functions --- //

#[inline]
Node<T>: Node<T> = {
    // <start:@L> <t:T> <end:@R> => node(t, start.expand(&end)),
    <start:@L> <t:T> <end:@R> => {
        let (line, col) = lookup.get(start);
        NodeData::new(t, Source::Known { span: start..end, line, col }).share()
    },
    // <t:T> => node(t, Source::Unknown),
}

/// One or more `T`s, delimited by interposed separator `S`.
Delim1<T, S>: Delim<T> = {
    T => {
        Delim{ vec:vector!(<>), has_trailing: false }
    },
    <mut v:(<T> S)+> <e:T?> => match e {
        None => {
            Delim{ vec:v.into(), has_trailing: true }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v.into(), has_trailing: false }
        }
    }
};

/// Zero or more `T`s, delimited by interposed separator `S`.
Delim0<T, S>: Delim<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => {
            let has_trailing = v.len() > 0;
            Delim{ vec:v.into(), has_trailing }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v.into(), has_trailing: false }
        }
    }
};

Bl : Exp = {
    r"\\\\BIG.FART." => unreachable!()
}

Ob : Exp = {
    ExpObj
}

// --- Terminals --- //

NatIndex: usize = {
    r"[0-9]([0-9_]*[0-9])?" => <>.replace('_', "").parse().unwrap(),
}

Id: Id = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_id(),
};

#[inline]
Id_: Id_ = Node<Id>;

// --- Literals --- //

pub Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "(" ")" => Literal::Unit,
    r"[+-]?[0-9]([0-9_]*[0-9])?[Ee][0-9]([0-9_]*[0-9])?" => Literal::Float(<>.to_string()), // exponential without decimal
    r"[+-]?[0-9]([0-9_]*[0-9])?\.([0-9]([0-9_]*[0-9])?)?([Ee][0-9]([0-9_]*[0-9])?)?" => Literal::Float(<>.to_string()), // exponential with decimal
    r"0x[0-9a-fA-F]+" => Literal::Nat(<>.to_string()), // hexadecimal
    r"[0-9]([0-9_]*[0-9])?" => Literal::Nat(<>.to_string()),
    r"'(?:[^\\'\s]|\\.)*'|' '" => Literal::Char(<>.to_string()), // TODO: more test cases
    <s:StringLiteral> => Literal::Text(s),
}

StringLiteral: String = {
    r#""(?:[^\\"\n]|\\.)*""# => <>.to_string(), // TODO more test cases
}

// --- Patterns --- //

#[inline]
PatPlain_: Pat_ = Node<PatPlain>;

PatPlain: Pat = {
    "_" => Pat::Wild,
    Id_ => Pat::Var(<>),
    Literal => Pat::Literal(<>),
    "(" <ps:Delim1<PatBin_, ",">> ")" => get_one(ps).map(Pat::Paren).unwrap_or_else(Pat::Tuple),
}

#[inline]
PatNullary_: Pat_ = Node<PatNullary>;

PatNullary: Pat = {
    PatPlain,
    // to do -- copy more cases from parser.mly
}

#[inline]
PatBin_: Pat_ = Node<PatBin>;

PatBin: Pat = {
    <p:PatBin_> ":" <t:Type_> => Pat::Annot(p, t),
    PatUn,
    // to do -- copy more cases from parser.mly
}

PatUn: Pat = {
    PatNullary,
    "#" <s:Id_> => Pat::Variant(s, None),
    "#" <s:Id_> <p:PatNullary_> => Pat::Variant(s, Some(p)),

}

#[inline]
Pat_: Pat_ = Node<Pat>;

pub Pat: Pat = {
    PatBin,
}

// --- Types --- //


TypeObj: Type = {
    "{" <tfs:Delim0<TypeField_, ";">> "}" => Type::Object(ObjSort::Object, tfs),
}

TypeVariant: Type = {
    "{" "#" "}" => Type::Variant(Delim::new()),
    "{" <tts:Delim1<TypeTag_, ";">> "}" => Type::Variant(tts),
}

#[inline]
TypeTag_: TypeTag_ = Node<TypeTag>;

TypeTag: TypeTag = {
    "#" <id:Id_> <typ:(":" <Type_>)?> => TypeTag{ id, typ },
}

#[inline]
TypeField_: TypeField_ = Node<TypeField>;

TypeField: TypeField = {
//    "type" <id:Id_> <tps:TypeParamsOpt> "=" <t:Type_> => TypeField::Type,
    <mut_:VarOpt> <id:Id_> ":" <typ:Type_> => TypeField::Val(ValTypeField{mut_, id, typ }),
//    <id:Id_> <tps:TypeParamsOpt> <t1:TypeNullary_> ":" <t2:Type_> => TypeField::Type,
}

#[inline]
TypeNullary_: Type_ = Node<TypeNullary>;

pub TypeNullary: Type = {
    "(" <ts:Delim1<TypeItem_, ",">> ")" => Type::Tuple(ts),
    "(" ")" => Type::Prim(PrimType::Unit),
    <id:Id_> <ta:TypeArgs> => {
        // assuming here that no primitive types are parameterized by type args.
        if let None = ta {
            PrimType::from_ident(&id.0).map(Type::Prim).unwrap_or_else(|| Type::Path(TypePath::Id(id), None))
        } else {
            Type::Path(TypePath::Id(id), ta)
        }
    },
    <p:TypePath_> "." <id:Id_> <ta:TypeArgs> => Type::Path(TypePath::Dot(p, id), ta),
    "[" <vo:VarOpt> <t:Type_> "]" => Type::Array(vo, t),
    TypeObj,
    TypeVariant
}

#[inline]
TypePath_: TypePath_ = Node<TypePath>;

TypePath: TypePath = {
    Id_ => TypePath::Id(<>),
    <p:TypePath_> "." <id:Id_> => TypePath::Dot(p, id),
}

#[inline]
TypeUn_: Type_ = Node<TypeUn>;

pub TypeUn: Type = {
    TypeNullary,
    "?" <t:TypeUn_> => Type::Optional(t),
}

#[inline]
TypePre_: Type_ = Node<TypePre>;

pub TypePre: Type = {
    TypeUn,
    "prim" <id:Id_> => PrimType::from_ident(&id.0).map(Type::Prim).unwrap_or_else(|| Type::Unknown(id)),
    "async" <t:TypePre_> => Type::Async(t),
    // actor
    // class
    // object
}

#[inline]
TypeNoBin_: Type_ = Node<TypeNoBin>;

pub TypeNoBin: Type = {
    TypePre,
    <fso:FuncSortOpt> <tps:TypeParamsOpt> <t1:TypeUn_> "->" <t2:TypeNoBin_> =>
        Type::Function(fso, tps, t1, t2),
}

#[inline]
Type_: Type_ = Node<Type>;

pub Type: Type = {
    TypeNoBin,
}

#[inline]
TypeItem_: Type_ = Node<TypeItem>;

pub TypeItem: Type = {
    <id:Id_> ":" <t:Type_> => Type::Item(id, t),
    Type,
}

pub TypeArgs: Option<Delim<Type_>> = {
    => None,
    "<" <d:Delim0<Type_, ",">> ">" => Some(d)
}

// --- Programs --- //

pub Prog: Decs = {
    Decs,
}

// --- Expressions --- //

#[inline]
Exp_<B>: Exp_ = Node<Exp<B>>;

#[inline]
ExpPlain_: Exp_ = Node<ExpPlain>;

ExpPlain: Exp = {
    Literal => Exp::Literal(<>),
    "(" <es:Delim1<Exp_<Ob>, ",">> ")" => get_one(es).map(Exp::Paren).unwrap_or_else(Exp::Tuple),
    // "`" "(" <e:Exp<Ob>> ")" => e,
}

#[inline]
ExpNullary_<B>: Exp_ = Node<ExpNullary<B>>;

ExpNullary<B>: Exp = {
    B,
    ExpPlain,
    Id => Exp::Var(<>),
    "prim" <t:StringLiteral> => Exp::Prim(PrimFunction::resolve(t)),
}

#[inline]
ExpPost_<B>: Exp_ = Node<ExpPost<B>>;

VarOpt: Mut = {
    "var" => Mut::Var,
     => Mut::Const,
}

ExpPost<B>: Exp = {
    ExpNullary<B>,
    "[" <v:VarOpt> <es:Delim0<ExpNonVar_<Ob>, ",">> "]" => Exp::Array(v, es),
    <e1:ExpPost_<B>> "[" <e2:Exp_<Ob>> "]" => Exp::Index(e1, e2),
    <e1:ExpPost_<B>> "." <i:NatIndex> => Exp::Proj(e1, i),
    <e1:ExpPost_<B>> "." <i:Id_> => Exp::Dot(e1, i),
    <e1:ExpPost_<B>> <inst:Inst> <e2:ExpNullary_<Ob>> => Exp::Call(e1, inst, e2),
    <e:ExpPost_<B>> "!" => Exp::Bang(e),
}

#[inline]
Inst: Option<Delim<Type_>> = {
    => None,
  "<" <ts:Delim0<Type_, ",">> ">" => Some(ts),
}

ExpUn<B>: Exp = {
    ExpPost<B>,
    "#" <x:Id_> <e:(ExpNullary_<B>)?> => Exp::Variant(x, e),
    "?" <e:ExpUn_<Ob>> => Exp::Opt(e),
    <u:UnOp> <e:ExpUn_<B>> => Exp::Un(u, e),
    "not" <e:ExpUn_<B>> => Exp::Not(e),
}

#[inline]
ExpUn_<B>: Exp_ = Node<ExpUn<B>>;

#[inline]
ExpNest_: Exp_ = Node<ExpNest>;

ExpNest: Exp = {
    Block,
    Exp<Bl>,
}

Exp<B>: Exp = {
    ExpNonVar<B>,
    DecVar_ => dec_node_into_exp(<>),
}

Block: Exp = {
    "{" <ds:Decs> "}" => Exp::Block(ds)
}

#[inline]
Block_: Exp_ = Node<Block>;

ExpObj: Exp = {
    "{" <efs:Delim0<ExpField_, ";">> "}" => Exp::Object(efs)
}

#[inline]
ExpNonVar_<B>: Exp_ = Node<ExpNonVar<B>>;

ExpNonVar<B>: Exp = {
    ExpNonDec<B>,
    DecNonVar_ => dec_node_into_exp(<>),
}

#[inline]
ExpNonDec_<B>: Exp_ = Node<ExpNonDec<B>>;

ExpNonDec<B>: Exp = {
    ExpBin<B>,
    <e1:ExpBin_<B>> ":=" <e2:Exp_<Ob>> => Exp::Assign(e1, e2),
    <e1:ExpBin_<B>> <b:BinAssign> <e2:ExpUn_<Ob>> => Exp::BinAssign(e1, b, e2),
    "if" <e1:ExpNullary_<Ob>> <e2:ExpNest_> "else" <e3:ExpNest_> => Exp::If(e1, e2, Some(e3)),
    // TODO: possibly use lookahead / lookbehind (=>@L, =>@R) for if without else
    // if without an else -- TEMP -- using placeholder token here but it doesn't belong.
    "if" <e1:ExpNullary_<Ob>> <e2:ExpNest_> "\\no_else" => Exp::If(e1, e2, None),
    // "return" => Exp::Return(None),
    "return" <e:Exp_<B>?> => Exp::Return(e),
    "switch" <e:ExpNullary_<Ob>> "{" <cs:Cases> "}" => Exp::Switch(e, cs),
    // "switch" <e:ExpNullary_<Ob>> <cs:Cases> => Exp::Switch(e, cs), // <<<< possible syntax?
    "while"  <e1:ExpNullary_<Ob>> <e2:ExpNest_> => Exp::While(e1, e2),
    "for" "(" <p:Pat_> "in" <e1:Exp_<Ob>> ")" <e2:ExpNest_> => Exp::For(p, e1, e2),
    "ignore" <e:ExpNest_> => Exp::Ignore(e),
    "do" <e:Block_> => Exp::Do(e),
    "do" "?" <e:Block_> => Exp::DoOpt(e),
    "assert" <e:ExpNest_> => Exp::Assert(e),
    "debug" <e:ExpNest_> => Exp::Debug(e),
    "import" <txt:StringLiteral> => Exp::Import(txt),

}

#[inline]
BinAssign: BinOp = {
  "+=" => BinOp::Add,
  "-=" => BinOp::Sub,
  "*=" => BinOp::Mul,
  "/=" => BinOp::Div,
  "%=" => BinOp::Mod,
  "**=" => BinOp::Pow,
  "&=" => BinOp::BitAnd,
  "|=" => BinOp::BitOr,
  "^=" => BinOp::Xor,
  "<<=" => BinOp::ShL,
  ">>=" => BinOp::ShR,
  "<<>=" => BinOp::RotL,
  "<>>=" => BinOp::RotR,
  "+%=" => BinOp::WAdd,
  "-%=" => BinOp::WSub,
  "*%=" => BinOp::WMul,
  "**%=" => BinOp::WPow,
  "#=" => BinOp::Cat,
}

#[inline]
ExpBin_<B>: Exp_ = Node<ExpBin<B>>;

ExpBin<B>: Exp = {
    <e1:ExpBin_<B>> "==" <e2:ExpBin0_<B>> => Exp::Rel(e1, RelOp::Eq, e2),
    <e1:ExpBin_<B>> "!=" <e2:ExpBin0_<B>> => Exp::Rel(e1, RelOp::Neq, e2),
    ExpBin000<B>,
}

#[inline]
ExpBin000_<B>: Exp_ = Node<ExpBin000<B>>;

ExpBin000<B>: Exp = {
    <e1:ExpBin000_<B>> "or" <e2:ExpBin00_<B>> => Exp::Or(e1, e2),
    ExpBin00<B>,
}

#[inline]
ExpBin00_<B>: Exp_ = Node<ExpBin00<B>>;

ExpBin00<B>: Exp = {
    <e1:ExpBin00_<B>> "and" <e2:ExpBin0_<B>> => Exp::And(e1, e2),
    ExpBin0<B>,
}

#[inline]
ExpBin0_<B>: Exp_ = Node<ExpBin0<B>>;

ExpBin0<B>: Exp = {
    <e1:ExpBin0_<B>> "+" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::Add, e2),
    <e1:ExpBin0_<B>> "+%" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::WAdd, e2),
    <e1:ExpBin0_<B>> "-" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::Sub, e2),
    <e:ExpBin0_<B>> ":" <t:Type_> => Exp::Annot(e, t),
    ExpBin1<B>,
}

#[inline]
ExpBin1_<B>: Exp_ = Node<ExpBin1<B>>;

ExpBin1<B>: Exp = {
    <e1:ExpBin2_<B>> "*" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::Mul, e2),
    <e1:ExpBin2_<B>> "/" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::Div, e2),
    ExpBin2<B>,
}

#[inline]
ExpBin2_<B>: Exp_ = Node<ExpBin2<B>>;

ExpBin2<B>: Exp = {
    <e1:ExpBin3_<B>> "|" <e2:ExpBin2_<B>> => Exp::Bin(e1, BinOp::BitOr, e2),
    ExpBin3<B>,
}

#[inline]
ExpBin3_<B>: Exp_ = Node<ExpBin3<B>>;

ExpBin3<B>: Exp = {
    <e1:ExpUn_<B>> "&" <e2:ExpBin3_<B>> => Exp::Bin(e1, BinOp::BitAnd, e2),
    ExpUn<B>,
}

Cases: Cases = {
    Delim0<Node<Case>, ";">
}

Case: Case = {
    "case" <pat:PatNullary_> <exp:ExpNest_> => Case{pat, exp},
}

#[inline]
ExpField_: Node<ExpField> = Node<ExpField>;

ExpField: ExpField = {
    <mut_:VarOpt> <id:Id_> <typ:(":" <Type_>)?> "=" <exp:Exp_<Ob>> => ExpField{ mut_, id, exp, typ }
}

Decs: Decs = {
    Delim0<Dec_, ";">
}

#[inline]
Dec_: Dec_ = Node<Dec>;

Dec: Dec = {
    DecVar,
    DecNonVar,
    ExpNonDec_<Ob> => Dec::Exp(<>),
}

#[inline]
DecNonVar_: Dec_ = Node<DecNonVar>;

DecNonVar: Dec = {
    "import" <p:PatNullary_> <s:"="?> <txt:StringLiteral> => Dec::LetImport(p, Sugar(s.is_some()), txt),
    "let" <p:Pat_> "=" <e:Exp_<Ob>> => Dec::Let(p, e),
    "module" <i:(Id_)?> <s:"="?> <ob:ObjBody> => Dec::LetModule(i, Sugar(s.is_some()), ob),
    "actor" <i:(Id_)?> <s:"="?> <ob:ObjBody> => Dec::LetActor(i, Sugar(s.is_some()), ob),
    <sp:SharedPatOpt> "func" <i:(Id_)?> <tpo:TypeParamsOpt> <p:PatPlain_> <t:(":" Type_)?> <b:Block_> => Dec::Func(Function {
        name: i, shared: sp, binds: tpo, input: p, output: t.map(|t|{t.1}), sugar: Sugar(false), exp: b,
    }),
    <sp:SharedPatOpt> "func" <i:(Id_?)> <tpo:TypeParamsOpt> <p:PatPlain_> <t:(":" Type_)?> "=" <e:Exp_<Ob>> => Dec::Func(Function {
        name: i, shared: sp, binds: tpo, input: p, output: t.map(|t|{t.1}), sugar: Sugar(true), exp: e,
    }),
    "type" <id:Id_> <tps:TypeParamsOpt> "=" <t:Type_> => Dec::Type(id, tps, t),
    // TODO -- 20221128-1816.
    // class
    // actor class
}

#[inline]
TypeParamsOpt: Option<Delim<TypeBind_>> = {
    => None,
    "<" <ts:Delim0<Type, ",">> ">" => None // to do -- produce AST.
}

#[inline]
SharedPatOpt: Option<SortPat> = {
    => None,
  "shared" => None, // to do -- produce AST.
  "shared" "query" <op:PatOpt> => None, // to do -- produce AST.
  "query" <op:PatOpt> => None, // to do -- produce AST.
}

#[inline]
FuncSortOpt: Option<SortPat> = {
  <q:"query"?> => None, // to do -- produce AST.
  "shared" <q:"query"?> => None, // to do -- produce AST.
}

#[inline]
PatOpt: Option<Pat> = {
 PatPlain => None, // to do
  => None
}

#[inline]
DecVar_: Dec_ = Node<DecVar>;

DecVar: Dec = {
    "var" <p:Pat_> "=" <e:Exp_<Ob>> => Dec::Var(p, e),
}

UnOp: UnOp = {
    "+" => UnOp::Pos,
    "-" => UnOp::Neg,
    "^" => UnOp::Not,
}

BinOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "**" => BinOp::Pow,
    "+%" => BinOp::WAdd,
    "-%" => BinOp::WSub,
    "*%" => BinOp::WMul,
    "**%" => BinOp::WPow,
    "&" => BinOp::And,
    "|" => BinOp::Or,
    "^" => BinOp::Xor,
    "<<" => BinOp::ShL,
//    " >>" => BinOp::Shr,
    "<<>" => BinOp::RotL,
    "<>>" => BinOp::RotR,
    "#" => BinOp::Cat,
}

ObjBody: DecFields = {
    "{" <dfs:Delim0<DecField_, ";">> "}" => dfs
}

#[inline]
Vis_: Vis_ = Node<Vis>;

Vis: Vis = {
  "public" => Vis::Public(None),
  "private" => Vis::Private,
}

#[inline]
Stab_: Stab_ = Node<Stab>;

Stab: Stab = {
  "stable" => Stab::Stable,
  "flexible" => Stab::Flexible,
}

#[inline]
DecField_: DecField_ = Node<DecField>;

DecField: DecField = {
    <vis:(Vis_)?> <stab:(Stab_)?> <dec:Dec_> => DecField{ vis, stab, dec }
}
