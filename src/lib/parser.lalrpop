use std::str::FromStr;
//use std::collections::HashMap;
use crate::parser_utils::{dec_into_exp, get_one};
use crate::ast::{Id, Id_, Pat, Pat_, Exp, Exp_, ExpField, Type, Type_, PrimType, Literal, Case, Cases, Decs, Dec, UnOp, BinOp, Delim, Mut};

grammar;

// Terminals

NatIndex: usize = {
    r"[0-9]+" => <>.parse().unwrap(),
}

Id: Id = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};

Id_: Id_ = {
    Id => Box::new(<>)
}

VarExp: Exp = {
    Id => Exp::Var(<>),
}

VarExp_: Exp_ = {
    Id => Box::new(Exp::Var(<>)),
}

// --- Helper Functions --- //

/// One or more `T`s, delimited by interposed separator `S`.
Delim1<T, S>: Delim<T> = {
    T => {
        Delim{ vec:vec!(<>), has_trailing: false }
    },
    <mut v:(<T> S)+> <e:T?> => match e {
        None => {
            Delim{ vec:v, has_trailing: true }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v, has_trailing: false }
        }
    }
};

/// Zero or more `T`s, delimited by interposed separator `S`.
Delim0<T, S>: Delim<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => {
            let has_trailing = v.len() > 0;
            Delim{ vec:v, has_trailing }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v, has_trailing: false }
        }
    }
};

Bl : Exp = {
    r"\\\\BIG.FART." => unreachable!()
}

Ob : Exp = {
    ExpObj
}

// --- Literals --- //

pub Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "(" ")" => Literal::Unit,
    r"-?[0-9]+\.[0-9]*" => Literal::Float(<>.to_string()), // TODO: possibly use JSON parser for float and string literals?
    r"-[0-9]+" => Literal::Int(<>.to_string()),
    r"[0-9]+" => Literal::Nat(<>.to_string()),
    r"'([^']|')'" => Literal::Char(<>.to_string()), // TODO: more test cases
    r#""(?:[^\\"]|\.)*""# => Literal::Text(<>.to_string()), // TODO more test cases
}

// --- Patterns --- //

pub PatPlain: Pat = {
    "_" => Pat::Wild,
    Id => Pat::Var(<>),
    Literal => Pat::Literal(<>),
    "(" <ps:Delim1<PatBin, ",">> ")" => get_one(ps).map(Pat::Paren).unwrap_or_else(Pat::Tuple),
}

pub PatNullary: Pat = {
    PatPlain,
    // to do -- copy more cases from parser.mly
}

pub PatBin_: Pat_ = { PatBin => Box::new(<>) }

pub PatBin: Pat = {
    <p:PatBin_> ":" <t:Type> => Pat::Annot(p, t),
    PatUn,
    // to do -- copy more cases from parser.mly
}

pub PatUn: Pat = {
    PatNullary,
    "#" <s:Id> => Pat::Variant(s, None),
    "#" <s:Id> <p:PatNullary> => Pat::Variant(s, Some(Box::new(p))),
}

pub Pat = {
    PatBin,
}

// pub PatBeforeType: Pat = {
//     "_" => Pat::Wild,
//     Id => Pat::Var(<>),
//     Literal => Pat::Literal(<>),
//     // TODO: Signed(Vec<UnOp>, Pat_)
//     "(" <ps:Delim1<Pat, ",">> ")" => get_one(ps).unwrap_or_else(Pat::Tuple),
//     // TODO: Object(Vec<(Id, Pat)>)
//     "?" <p:PatBeforeType> => Pat::Optional(Box::new(p)),
//     "#" <s:Id> ":" <p:PatBeforeType?> => Pat::Variant(s, Box::new(p.unwrap_or(Pat::Wild))), // should we allow whitespace after '#' symbol?
// }

// pub PatBeforeAlt: Pat = {
//     PatBeforeType,
//     <p:PatBeforeType> <t:TypeAnnot> => Pat::Annot(Box::new(p), t),
// }

// --- Types --- //

pub PrimType: PrimType = {
    "(" ")" => PrimType::Unit,
    "Bool" => PrimType::Bool,
    "Nat" => PrimType::Nat,
    "Nat8" => PrimType::Nat8,
    "Nat16" => PrimType::Nat16,
    "Nat32" => PrimType::Nat32,
    "Nat64" => PrimType::Nat64,
    "Int" => PrimType::Int,
    "Int8" => PrimType::Int8,
    "Int16" => PrimType::Int16,
    "Int32" => PrimType::Int32,
    "Int64" => PrimType::Int64,
    "Principal" => PrimType::Principal,
    "Text" => PrimType::Text,
}

pub Type_: Type_ = {
    Type => Box::new(<>),
}

pub Type: Type = {
    PrimType => Type::Prim(<>),
    // TODO
}

// --- Programs --- //

pub Prog: Decs = {
    Decs,
}

// --- Expressions --- //

Exp_<B>: Exp_ = {
    Exp<B> => Box::new(<>)
}

ExpPlain_: Exp_ = {
    ExpPlain => Box::new(<>),
}

ExpPlain: Exp = {
    Literal => Exp::Literal(<>),
    "(" <es:Delim1<Exp<Ob>, ",">> ")" => get_one(es).map(Exp::Paren).unwrap_or_else(Exp::Tuple),
    "`" "(" <e:Exp<Ob>> ")" => e,
}

#[inline]
ExpNullary_<B>: Exp_ = {
    ExpNullary<B> => Box::new(<>),
}

ExpNullary<B>: Exp = {
    B,
    ExpPlain => <>,
    Id => Exp::Var(<>),
    // Prim
}

ExpPost_<B>: Exp_ = {
    ExpPost<B> => Box::new(<>),
}

VarOpt: Mut = {
    "var" => Mut::Var,
     => Mut::Const,
}

ExpPost<B>: Exp = {
    ExpNullary<B>,
    "[" <v:VarOpt> <es:Delim0<ExpNonVar<Ob>, ",">> "]" => Exp::Array(v, es),
    <e1:ExpPost_<B>> "[" <e2:Exp_<Ob>> "]" => Exp::Idx(e1, e2),
    <e1:ExpPost_<B>> "." <i:NatIndex> => Exp::Proj(e1, i),
    <e1:ExpPost_<B>> "." <i:Id> => Exp::Dot(e1, i),
    <e:ExpPost_<B>> "!" => Exp::Bang(e),
}

ExpUn<B>: Exp = {
    ExpPost<B>,
    "#" <x:Id_> <e:(ExpNullary_<B>)?> => Exp::Variant(x, e),
    "?" <e:ExpUn_<Ob>> => Exp::Opt(e),
    <u:UnOp> <e:ExpUn_<B>> => Exp::Un(u, e),
    "not" <e:ExpUn_<B>> => Exp::Not(e),
}

ExpUn_<B>: Exp_ = {
    ExpUn<B> => Box::new(<>),
}

ExpNest_: Exp_ = {
    ExpNest => Box::new(<>),
}

ExpNest: Exp = {
    Block,
    Exp<Bl>,
}

Exp<B>: Exp = {
    ExpNonVar<B>,
    DecVar => dec_into_exp(<>),
}

Block: Exp = {
    "{" <ds:Decs> "}" => Exp::Block(ds)
}

Block_: Exp_ = { Block => Box::new(<>) }

ExpObj: Exp = {
    "{" <efs:Delim0<ExpField, ";">> "}" => Exp::Object(efs)
}

ExpNonVar<B>: Exp = {
    ExpNonDec<B>,
    DecNonVar => dec_into_exp(<>),
}

ExpNonDec<B>: Exp = {
    ExpBin<B>,
    <e1:ExpUn_<B>> ":=" <e2:ExpUn_<B>> => Exp::Assign(e1, e2),
    // TODO: remove 
    "if" <e1:ExpNullary_<Ob>> <e2:ExpNest_> "else" <e3:ExpNest_> => Exp::If(e1, e2, Some(e3)),
    // if without an else -- TEMP -- using semi here but it doesn't belong.
    "if" <e1:ExpNullary_<Ob>> <e2:ExpNest_> "\\no_else" => Exp::If(e1, e2, None),
    "return" => Exp::Return(Box::new(Exp::Literal(Literal::Unit))),
    "return" <e:Exp_<B>> => Exp::Return(e),
    "switch" <e:ExpNullary_<Ob>> "{" <cs:Cases> "}" => Exp::Switch(e, cs),
    // "switch" <e:ExpNullary_<Ob>> <cs:Cases> => Exp::Switch(e, cs), // <<<< possible syntax?
    "ignore" <e:ExpNest_> => Exp::Ignore(e),
    "do" <e:Block_> => Exp::Do(e),
}

ExpVar_: Exp_ = {
    <x:Id> => Box::new(Exp::Var(x)),
}

ExpBin_<B>: Exp_ = {
    ExpBin<B> => Box::new(<>),
}

ExpBin<B>: Exp = {
    <e1:ExpBin1_<B>> "+" <e2:ExpBin_<B>> => Exp::Bin(e1, BinOp::Add, e2),
    ExpBin1<B>,
}

ExpBin1_<B>: Exp_ = {
    ExpBin1<B> => Box::new(<>),
}

ExpBin1<B>: Exp = {
    <e1:ExpBin2_<B>> "*" <e2:ExpBin1_<B>> => Exp::Bin(e1, BinOp::Mul, e2),
    ExpBin2<B>,
}

ExpBin2_<B>: Exp_ = {
    ExpBin2<B> => Box::new(<>),
}

ExpBin2<B>: Exp = {
    <e1:ExpBin3_<B>> "|" <e2:ExpBin2_<B>> => Exp::Bin(e1, BinOp::BitOr, e2),
    ExpBin3<B>,
}

ExpBin3_<B>: Exp_ = {
    ExpBin3<B> => Box::new(<>),
}

ExpBin3<B>: Exp = {
    <e1:ExpUn_<B>> "&" <e2:ExpBin3_<B>> => Exp::Bin(e1, BinOp::BitAnd, e2),
    ExpUn<B>,
}

TextId: String = {
   Id,
}

Cases: Cases = {
    Delim0<Case, ";">
}

Case: Case = {
    "case" <pat:PatNullary> <exp:ExpNest> => Case{pat, exp},
}

ExpField: ExpField = {
    <mut_:VarOpt> <id:Id> <typ:(":" <Type>)?> "=" <exp:Exp<Ob>> => ExpField{ mut_, id, exp, typ }
}

Decs: Decs = {
    Delim0<Dec, ";">
}

Dec: Dec = {
    DecVar,
    DecNonVar,
    ExpNonDec<Ob> => Dec::Exp(<>),
}

DecNonVar: Dec = {
    "let" <p:Pat> "=" <e:Exp<Ob>> => Dec::Let(p, e),
    // type
    // class
    // actor class
}

DecVar: Dec = {
    "var" <p:Pat> "=" <e:Exp<Ob>> => Dec::Var(p, e),
}

UnOp: UnOp = {
    "+" => UnOp::Pos,
    "-" => UnOp::Neg,
    "^" => UnOp::Not,
}

BinOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "**" => BinOp::Pow,
    "+%" => BinOp::WAdd,
    "-%" => BinOp::WSub,
    "*%" => BinOp::WMul,
    "**%" => BinOp::WPow,
    "&" => BinOp::And,
    "|" => BinOp::Or,
    "^" => BinOp::Xor,
    "<<" => BinOp::ShL,
//    " >>" => BinOp::Shr,
    "<<>" => BinOp::RotL,
    "<>>" => BinOp::RotR,
    "#" => BinOp::Cat,
}

// Precedence
// -----------
// %nonassoc RETURN_NO_ARG IF_NO_ELSE LOOP_NO_WHILE
// %nonassoc ELSE WHILE
// %left COLON
// %left OR
// %left AND
// %nonassoc EQOP NEQOP LEOP LTOP GTOP GEOP
// %left ADDOP SUBOP WRAPADDOP WRAPSUBOP HASH
// %left MULOP WRAPMULOP DIVOP MODOP
// %left OROP
// %left ANDOP
// %left XOROP
// %nonassoc SHLOP SHROP ROTLOP ROTROP
// %left POWOP WRAPPOWOP
