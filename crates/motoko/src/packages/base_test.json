{"name":"base-test","version":"master","files":{"floatTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Float \"mo:base/Float\";\n\nDebug.print(\"Float\");\n\ndo {\n  Debug.print(\"  abs\");\n\n  assert(Float.abs(1.1) == 1.1);\n  assert(Float.abs(-1.1) == 1.1);\n};\n\ndo {\n  Debug.print(\"  ceil\");\n\n  assert(Float.ceil(1.1) == 2.0);\n};\n\ndo {\n  Debug.print(\"  floor\");\n\n  assert(Float.floor(1.1) == 1.0);\n};\n\ndo {\n  Debug.print(\"  trunc\");\n\n  assert(Float.trunc(1.0012345789) == 1.0);\n};\n\ndo {\n  Debug.print(\"  nearest\");\n\n  assert(Float.nearest(1.00001) == 1.0);\n  assert(Float.nearest(1.99999) == 2.0);\n};\n\ndo {\n  Debug.print(\"  min\");\n\n  assert(Float.min(1.1, 2.2) == 1.1);\n};\n\ndo {\n  Debug.print(\"  max\");\n\n  assert(Float.max(1.1, 2.2) == 2.2);\n};\n\ndo {\n  Debug.print(\"  sin\");\n\n  assert(Float.sin(0.0) == 0.0);\n};\n\ndo {\n  Debug.print(\"  cos\");\n\n  assert(Float.cos(0.0) == 1.0);\n};\n\ndo {\n  Debug.print(\"  toFloat64\");\n\n  assert(Float.toInt64(1e10) == (10000000000 : Int64));\n  assert(Float.toInt64(-1e10) == (-10000000000 : Int64));\n};\n\ndo {\n  Debug.print(\"  ofFloat64\");\n\n  assert(Float.fromInt64(10000000000) == 1e10);\n  assert(Float.fromInt64(-10000000000) == -1e10);\n};\n\n\ndo {\n  Debug.print(\"  format\");\n\n  assert(Float.format(#exact, 20.12345678901) == \"20.12345678901\");\n  assert(Float.format(#fix 6, 20.12345678901) == \"20.123457\");\n  assert(Float.format(#exp 9, 20.12345678901) == \"2.012345679e+01\");\n  assert(Float.format(#gen 12, 20.12345678901) == \"20.123456789\");\n  assert(Float.format(#hex 10, 20.12345678901) == \"0x1.41f9add374p+4\");\n};\n\n\ndo {\n  Debug.print(\"  Pi: \" # Float.toText(Float.pi));\n  Debug.print(\"  arccos(-1.0): \" # Float.toText(Float.arccos(-1.)));\n\n  assert(Float.pi == Float.arccos(-1.));\n};\n\ndo {\n  Debug.print(\"  e: \" # debug_show(Float.toText(Float.e)));\n  Debug.print(\"  exp(1): \" # debug_show(Float.toText(Float.exp(1))));\n\n  assert(Float.e == Float.exp(1));\n};\n"},"resultTest.mo":{"content":"import Result \"mo:base/Result\";\nimport Int \"mo:base/Int\";\nimport Array \"mo:base/Array\";\nimport List \"mo:base/List\";\n\nimport Suite \"mo:matchers/Suite\";\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\n\nfunc makeNatural(x : Int) : Result.Result<Nat, Text> =\n  if (x >= 0) { #ok(Int.abs(x)) } else { #err(Int.toText(x) # \" is not a natural number.\") };\n\nfunc largerThan10(x : Nat) : Result.Result<Nat, Text> =\n  if (x > 10) { #ok(x) } else { #err(Int.toText(x) # \" is not larger than 10.\") };\n\nlet chain = Suite.suite(\"chain\", [\n  Suite.test(\"ok -> ok\",\n    Result.chain<Nat, Nat, Text>(makeNatural(11), largerThan10),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #ok(11)))\n  ),\n  Suite.test(\"ok -> err\",\n    Result.chain<Nat, Nat, Text>(makeNatural(5), largerThan10),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #err(\"5 is not larger than 10.\")))\n  ),\n  Suite.test(\"err\",\n    Result.chain<Nat, Nat, Text>(makeNatural(-5), largerThan10),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #err(\"-5 is not a natural number.\")))\n  ),\n]);\n\nlet flatten = Suite.suite(\"flatten\", [\n  Suite.test(\"ok -> ok\",\n    Result.flatten<Nat, Text>(#ok(#ok(10))),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #ok(10)))\n  ),\n  Suite.test(\"err\",\n    Result.flatten<Nat, Text>(#err(\"wrong\")),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #err(\"wrong\")))\n  ),\n  Suite.test(\"ok -> err\",\n    Result.flatten<Nat, Text>(#ok(#err(\"wrong\"))),\n    M.equals(T.result<Nat,Text>(T.natTestable, T.textTestable, #err(\"wrong\")))\n  ),\n]);\n\nlet iterate = Suite.suite(\"iterate\", do {\n  var tests : [Suite.Suite] = [];\n  var counter : Nat = 0;\n  Result.iterate(makeNatural(5), func (x : Nat) { counter += x });\n  tests := Array.append(tests, [Suite.test(\"ok\", counter, M.equals(T.nat(5)))]);\n  Result.iterate(makeNatural(-10), func (x : Nat) { counter += x });\n  tests := Array.append(tests, [Suite.test(\"err\", counter, M.equals(T.nat(5)))]);\n  tests\n});\n\nlet suite = Suite.suite(\"Result\", [\n  chain,\n  flatten,\n  iterate,\n]);\n\nSuite.run(suite);\n"},"arrayTest.mo":{"content":"import Array \"mo:base/Array\";\nimport Int \"mo:base/Int\";\nimport Nat \"../src/Nat\";\nimport Text \"mo:base/Text\";\nimport Result \"mo:base/Result\";\nimport Suite \"mo:matchers/Suite\";\nimport T \"mo:matchers/Testable\";\nimport M \"mo:matchers/Matchers\";\n\nlet suite = Suite.suite(\"Array\", [\n  Suite.test(\n    \"init\",\n    Array.freeze(Array.init<Int>(3, 4)),\n    M.equals(T.array<Int>(T.intTestable, [4, 4, 4]))),\n  Suite.test(\n    \"init empty\",\n    Array.freeze(Array.init<Int>(0, 4)),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"tabulate\",\n    Array.tabulate<Int>(3, func (i : Nat)= i * 2),\n    M.equals(T.array<Int>(T.intTestable, [0, 2, 4]))),\n  Suite.test(\n    \"tabulate empty\",\n    Array.tabulate<Int>(0, func (i : Nat) = i),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"tabulateVar\",\n    Array.freeze(Array.tabulateVar<Int>(3, func (i : Nat)= i * 2)),\n    M.equals(T.array<Int>(T.intTestable, [0, 2, 4]))),\n  Suite.test(\n    \"tabulateVar empty\",\n    Array.freeze(Array.tabulateVar<Int>(0, func (i : Nat) = i)),\n    M.equals(T.array<Int>(T.intTestable, []))),\n  Suite.test(\n    \"freeze\",\n    Array.freeze<Int>([ var 1, 2, 3 ]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3 ]))\n  ),\n  Suite.test(\n    \"freeze empty\",\n    Array.freeze<Int>([var]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"thaw round trip\",\n    Array.freeze(Array.thaw<Int>([1, 2, 3])),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"thaw round trip empty\",\n    Array.freeze(Array.thaw<Int>([])),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"equal\",\n    Array.equal<Int>([1, 2, 3], [1, 2, 3], Int.equal),\n    M.equals(T.bool(true))\n  ),\n  Suite.test(\n    \"equal empty\",\n    Array.equal<Int>([], [], Int.equal),\n    M.equals(T.bool(true))\n  ),\n  Suite.test(\n    \"not equal one empty\",\n    Array.equal<Int>([], [2, 3], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"not equal different lengths\",\n    Array.equal<Int>([1, 2, 3], [2, 4], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"not equal same lengths\",\n    Array.equal<Int>([1, 2, 3], [1, 2, 4], Int.equal),\n    M.equals(T.bool(false))\n  ),\n  Suite.test(\n    \"find\",\n    Array.find<Nat>([1, 9, 4, 8], func x = x == 9),\n    M.equals(T.optional(T.natTestable, ?9))\n  ),\n  Suite.test(\n    \"find fail\",\n    Array.find<Nat>([1, 9, 4, 8], func _ = false),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  Suite.test(\n    \"find empty\",\n    Array.find<Nat>([], func _ = true),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  Suite.test(\n    \"append\",\n    Array.append<Int>([1, 2, 3], [4, 5, 6]),\n    M.equals(T.array<Int>(T.intTestable, [ 1, 2, 3, 4, 5, 6 ]))\n  ),\n  Suite.test(\n    \"append first empty\",\n    Array.append<Int>([], [4, 5, 6]),\n    M.equals(T.array<Int>(T.intTestable, [4, 5, 6]))\n  ),\n  Suite.test(\n    \"append second empty\",\n    Array.append<Int>([1, 2, 3], []),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"append both empty\",\n    Array.append<Int>([], []),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\"sort\",\n    Array.sort([2, 3, 1], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\"sort empty array\",\n    Array.sort([], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\"sort already sorted\",\n    Array.sort([1, 2, 3, 4, 5], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3, 4, 5]))\n  ),\n  Suite.test(\"sort repeated elements\",\n    Array.sort([2, 2, 2, 2, 2], Nat.compare),\n    M.equals(T.array<Nat>(T.natTestable, [2, 2, 2, 2, 2]))\n  ),\n  Suite.test(\"sortInPlace\",\n    do {\n      let array = [var 2, 3, 1];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\"sortInPlace empty\",\n    do {\n      let array = [var];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\"sortInPlace already sorted\",\n    do {\n      let array = [var 1, 2, 3, 4, 5];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3, 4, 5]))\n  ),\n  Suite.test(\"sortInPlace repeated elements\",\n    do {\n      let array = [var 2, 2, 2, 2, 2];\n      Array.sortInPlace(array, Nat.compare);\n      Array.freeze(array)\n    },\n    M.equals(T.array<Nat>(T.natTestable, [2, 2, 2, 2, 2]))\n  ),\n  Suite.test(\n    \"reverse\",\n    Array.reverse<Nat>([0, 1, 2, 2, 3]),\n    M.equals(T.array<Nat>(T.natTestable, [3, 2, 2, 1, 0]))\n  ),\n  Suite.test(\n    \"reverse empty\",\n    Array.reverse<Nat>([]),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"reverse singleton\",\n    Array.reverse<Nat>([0]),\n    M.equals(T.array<Nat>(T.natTestable, [0]))\n  ),\n  Suite.test(\n    \"map\",\n    Array.map<Nat, Bool>([1, 2, 3], func x = x % 2 == 0),\n    M.equals(T.array<Bool>(T.boolTestable, [false, true, false]))\n  ),\n  Suite.test(\n    \"map empty\",\n    Array.map<Nat, Bool>([], func x = x % 2 == 0),\n    M.equals(T.array<Bool>(T.boolTestable, []))\n  ),\n  Suite.test(\n    \"filter\",\n    Array.filter<Nat>([1, 2, 3, 4, 5, 6], func x = x % 2 == 0),\n    M.equals(T.array<Nat>(T.natTestable, [2, 4, 6]))\n  ),\n  Suite.test(\n    \"filter empty\",\n    Array.filter<Nat>([], func x = x % 2 == 0),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapEntries\",\n    Array.mapEntries<Nat, Nat>([1, 2, 3], func (x, i) = x + i),\n    M.equals(T.array<Nat>(T.natTestable, [1, 3, 5]))\n  ),\n  Suite.test(\n    \"mapEntries empty\",\n    Array.mapEntries<Nat, Nat>([], func (x, i) = x + i),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapFilter\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3, 4, 5, 6], func x { if (x % 2 == 0) ?x else null }),\n    M.equals(T.array<Nat>(T.natTestable, [2, 4, 6]))\n  ),\n  Suite.test(\n    \"mapFilter keep all\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3], func x = ?x),\n    M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"mapFilter keep none\",\n    Array.mapFilter<Nat, Nat>([1, 2, 3], func _ = null),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapFilter empty\",\n    Array.mapFilter<Nat, Nat>([], func x { if (x % 2 == 0) ?x else null }),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  Suite.test(\n    \"mapResult\",\n    Array.mapResult<Int, Nat, Text>(\n      [1, 2, 3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #ok([1, 2, 3])))\n  ),\n  Suite.test(\n    \"mapResult fail first\",\n    Array.mapResult<Int, Nat, Text>(\n      [-1, 2, 3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #err \"error message\"))\n  ),\n  Suite.test(\n    \"mapResult fail last\",\n    Array.mapResult<Int, Nat, Text>(\n      [1, 2, -3],\n      func x { if (x >= 0) { #ok(Int.abs x) } else { #err \"error message\"} }),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #err \"error message\"))\n  ),\n  Suite.test(\n    \"mapResult empty\",\n    Array.mapResult<Nat, Nat, Text>(\n      [],\n      func x = #ok x),\n    M.equals(T.result<[Nat], Text>(T.arrayTestable(T.natTestable), T.textTestable, #ok([])))\n  ),\n  Suite.test(\n    \"chain\",\n    Array.chain<Int, Int>([0, 1, 2], func x = [x, -x]),\n    M.equals(T.array<Int>(T.intTestable, [0, 0, 1, -1, 2, -2]))\n  ),\n  Suite.test(\n    \"chain empty\",\n    Array.chain<Int, Int>([], func x = [x, -x]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"foldLeft\",\n    Array.foldLeft<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", Text.concat),\n    M.equals(T.text(\"abc\"))\n  ),\n  Suite.test(\n    \"foldLeft empty\",\n    Array.foldLeft<Text, Text>([], \"base\", Text.concat),\n    M.equals(T.text(\"base\"))\n  ),\n  Suite.test(\n    \"foldRight\",\n    Array.foldRight<Text, Text>([ \"a\", \"b\", \"c\" ], \"\", func (x, acc) = acc # x),\n    M.equals(T.text(\"cba\"))\n  ),\n  Suite.test(\n    \"foldRight empty\",\n    Array.foldRight<Text, Text>([], \"base\", Text.concat),\n    M.equals(T.text(\"base\"))\n  ),\n  Suite.test(\n    \"flatten\",\n    Array.flatten<Int>([[1, 2, 3], [], [1]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten empty start\",\n    Array.flatten<Int>([[], [1, 2, 3], [], [1]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten empty end\",\n    Array.flatten<Int>([[1, 2, 3], [], [1], []]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3, 1]))\n  ),\n  Suite.test(\n    \"flatten singleton\",\n    Array.flatten<Int>([[1, 2, 3]]),\n    M.equals(T.array<Int>(T.intTestable, [1, 2, 3]))\n  ),\n  Suite.test(\n    \"flatten empty\",\n    Array.flatten<Int>([[]]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"flatten empty\",\n    Array.flatten<Int>([]),\n    M.equals(T.array<Int>(T.intTestable, []))\n  ),\n  Suite.test(\n    \"make\",\n    Array.make<Int>(0),\n    M.equals(T.array<Int>(T.intTestable, [0]))\n  ),\n  Suite.test(\n    \"vals\",\n    do {\n      var sum = 0;\n      for (x in Array.vals([1, 2, 3])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(6))\n  ),\n  Suite.test(\n    \"vals empty\",\n    do {\n      var sum = 0;\n      for (x in Array.vals([])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(0))\n  ),\n  Suite.test(\n    \"keys\",\n    do {\n      var sum = 0;\n      for (x in Array.keys([1, 2, 3])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(3))\n  ),\n  Suite.test(\n    \"keys empty\",\n    do {\n      var sum = 0;\n      for (x in Array.keys([])) {\n        sum += x;\n      };\n      sum\n    },\n    M.equals(T.nat(0))\n  ),\n]);\n\nSuite.run(suite);\n"},"funcTest.mo":{"content":"import Function \"mo:base/Func\";\nimport Debug \"mo:base/Debug\";\nimport Text \"mo:base/Text\";\n\nDebug.print(\"Function\");\n\ndo {\n  Debug.print(\"  compose\");\n\n  func isEven(x : Int) : Bool { x % 2 == 0; };\n  func not_(x : Bool) : Bool { not x; };\n  let isOdd = Function.compose<Int, Bool, Bool>(not_, isEven);\n\n  assert(isOdd(0) == false);\n  assert(isOdd(1));\n};\n\ndo {\n  Debug.print(\"  const\");\n\n  assert(Function.const<Bool, Text>(true)(\"abc\"));\n  assert(Function.const<Bool, Text>(false)(\"abc\") == false);\n  assert(Function.const<Bool, (Text, Text)>(false)(\"abc\", \"abc\") == false);\n};\n"},"TrieExampleTest.mo":{"content":"import Trie \"mo:base/Trie\";\nimport Text \"mo:base/Text\";\nimport Iter \"mo:base/Iter\";\n\ndebug {\n  type Trie<K, V> = Trie.Trie<K, V>;\n  type Key<K> = Trie.Key<K>;\n\n  func key(t: Text) : Key<Text> { { key = t; hash = Text.hash t } };\n\n  let t0 : Trie<Text, Nat> = Trie.empty();\n  let t1 : Trie<Text, Nat> = Trie.put(t0, key \"hello\", Text.equal, 42).0;\n  let t2 : Trie<Text, Nat> = Trie.put(t1, key \"world\", Text.equal, 24).0;\n  let n : ?Nat = Trie.put(t1, key \"hello\", Text.equal, 0).1;\n  assert (n == ?42);\n\n  /// True if elements of a form a subset of those of b.\n  func isSubSet<X>(a : [X], b : [X], eq : (X, X) -> Bool) : Bool {\n    for (x in a.vals()) {\n      var found = false;\n      label here : () {\n        for (y in b.vals()) {\n          if (eq(x, y)) { found := true; break here };\n        }\n      };\n      if (not found) { return false };\n    };\n    return true\n  };\n\n  // note that `put(\"hello\", ..., 0)` happens \"after\" t2, but map is immutable (applicative).\n  let actual : [(Text, Nat)] = Iter.toArray(Trie.iter(t2));\n  let expected : [(Text, Nat)] = [(\"hello\", 42), (\"world\", 24)];\n  func equalKV(a : (Text, Nat), b : (Text, Nat)) : Bool { a == b };\n  assert (isSubSet(actual, expected, equalKV));\n  assert (isSubSet(expected, actual, equalKV));\n  assert Trie.isValid(t2, false);\n};\n"},"dequeTest.mo":{"content":"import Deque \"mo:base/Deque\";\nimport Iter \"mo:base/Iter\";\nimport O \"mo:base/Option\";\nimport D \"mo:base/Debug\";\n\n// test for Queue\ndo {\n    var l = Deque.empty<Nat>();\n    for (i in Iter.range(0, 100)) {\n        l := Deque.pushBack(l, i);\n    };\n    for (i in Iter.range(0, 100)) {\n        let x = Deque.peekFront(l);\n        switch (Deque.popFront(l)) {\n          case (?(y, l2)) { l := l2;\n             switch x {\n               case null assert false;\n               case (?x) assert (x == y) } };\n          case null { assert false };\n        };\n        assert(O.unwrap(x) == i);\n    };\n    O.assertNull(Deque.peekFront<Nat>(l));\n};\n\n// test for Deque\ndo {\n    var l = Deque.empty<Int>();\n    for (i in Iter.range(1, 100)) {\n        l := Deque.pushFront(l, -i);\n        l := Deque.pushBack(l, i);\n    };\n    label F for (i in Iter.revRange(100, -100)) {\n        if (i == 0) continue F;\n        let x = Deque.peekBack(l);\n        switch (Deque.popBack(l)) {\n          case (?(l2, y)) { l := l2;\n             switch x {\n               case null assert false;\n               case (?x) assert (x == y) } };\n          case null { assert false };\n        };\n        assert(O.unwrap(x) == i);\n    };\n};\n"},"optionTest.mo":{"content":"import Option \"mo:base/Option\";\nimport Debug \"mo:base/Debug\";\n\nDebug.print(\"Option\");\n\ndo {\n  Debug.print(\"  apply\");\n\n  do {\n    Debug.print(\"    null function, null value\");\n\n    let actual = Option.apply<Int, Bool>(null, null);\n    let expected : ?Bool = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    null function, non-null value\");\n\n     let actual = Option.apply<Int, Bool>(?0, null);\n    let expected : ?Bool = null;\n\n     switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    non-null function, null value\");\n\n     let isEven = func (x : Int) : Bool {\n      x % 2 == 0;\n    };\n\n    let actual = Option.apply<Int, Bool>(null, ?isEven);\n    let expected : ?Bool = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n   Debug.print(\"    non-null function, non-null value\");\n\n   let isEven = func (x : Int) : Bool {\n      x % 2 == 0;\n    };\n\n    let actual = Option.apply<Int, Bool>(?0, ?isEven);\n    let expected = ?true;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(actual_ == expected_);\n      };\n      case (_, _) {\n        assert(false);\n      };\n    };\n  };\n\n };\n\ndo {\n  Debug.print(\"  bind\");\n\n  do {\n    Debug.print(\"    null value to null value\");\n\n    let safeInt = func (x : Int) : ?Int {\n      if (x > 9007199254740991) {\n        null;\n      } else {\n        ?x;\n      }\n    };\n\n    let actual = Option.chain<Int, Int>(null, safeInt);\n    let expected : ?Int = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    non-null value to null value\");\n\n    let safeInt = func (x : Int) : ?Int {\n      if (x > 9007199254740991) {\n        null;\n      } else {\n        ?x;\n      }\n    };\n\n    let actual = Option.chain<Int, Int>(?9007199254740992, safeInt);\n    let expected : ?Int = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    non-null value to non-null value\");\n\n    let safeInt = func (x : Int) : ?Int {\n      if (x > 9007199254740991) {\n        null;\n      } else {\n        ?x;\n      }\n    };\n\n    let actual = Option.chain<Int, Int>(?0, safeInt);\n    let expected = ?0;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(actual_ == expected_);\n      };\n      case (_, _) {\n        assert(false);\n      };\n    };\n  };\n\n};\n\ndo {\n  Debug.print(\"  flatten\");\n\n  do {\n    Debug.print(\"    null value\");\n\n    let actual = Option.flatten<Int>(?null);\n    let expected : ?Int = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    non-null value\");\n    let actual = Option.flatten<Int>(??0);\n    let expected = ?0;\n\n     switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(actual_ == expected_);\n      };\n      case (_, _) {\n        assert(false);\n      };\n    };\n  };\n\n};\n\ndo {\n  Debug.print(\"  map\");\n\n  do {\n    Debug.print(\"    null value\");\n\n    let isEven = func (x : Int) : Bool {\n      x % 2 == 0;\n    };\n\n    let actual = Option.map<Int, Bool>(null, isEven);\n    let expected : ?Bool = null;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(false);\n      };\n      case (_, _) {\n        assert(true);\n      };\n    };\n  };\n\n  do {\n    Debug.print(\"    non-null value\");\n\n    let isEven = func (x : Int) : Bool {\n      x % 2 == 0;\n    };\n\n    let actual = Option.map<Int, Bool>(?0, isEven);\n    let expected = ?true;\n\n    switch (actual, expected) {\n      case (?actual_, ?expected_) {\n        assert(actual_ == expected_);\n      };\n      case (_, _) {\n        assert(false);\n      };\n    };\n  };\n\n};\ndo {\n  Debug.print(\"  iterate\");\n\n  do {\n    var witness = 0;\n    Option.iterate<Nat>(?(1), func (x : Nat) { witness += 1; });\n    assert(witness == 1);\n    Option.iterate<Nat>(null, func (x : Nat) { witness += 1; });\n    assert(witness == 1);\n  };\n};\n\ndo {\n  Debug.print(\"  make\");\n\n  let actual = Option.make<Int>(0);\n  let expected = ?0;\n\n  switch (actual, expected) {\n    case (?actual_, ?expected_) {\n      assert(actual_ == expected_);\n    };\n    case (_, _) {\n      assert(false);\n    };\n  };\n};\n"},"trieMapTest.mo":{"content":"import Prim \"mo:⛔\";\nimport H \"mo:base/TrieMap\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\n\ndebug {\n  let a = H.TrieMap<Text, Nat>(Text.equal, Text.hash);\n\n  assert a.size() == 0;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  assert a.size() == 1;\n  ignore a.remove(\"apple\");\n  assert a.size() == 0;\n\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n  a.put(\"Apple\", 11);\n  a.put(\"Banana\", 22);\n  a.put(\"Pear\", 33);\n  a.put(\"Avocado\", 44);\n  a.put(\"ApplE\", 111);\n  a.put(\"BananA\", 222);\n  a.put(\"PeaR\", 333);\n  a.put(\"AvocadO\", 444);\n\n  // need to resupply the constructor args; they are private to the object; but, should they be?\n  let b = H.clone<Text, Nat>(a, Text.equal, Text.hash);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure clone has each key present in original\n  for (k in a.keys()) {\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?_) {  };\n    };\n  };\n\n  // ensure clone has each value present in original\n  for (v in a.vals()) {\n    var foundMatch = false;\n    for (w in b.vals()) {\n      if (v == w) { foundMatch := true }\n    };\n    assert foundMatch\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // do some more operations:\n  a.put(\"apple\", 1111);\n  a.put(\"banana\", 2222);\n  a.delete(\"pear\");\n  a.delete(\"avocado\");\n\n  // check them:\n  switch (a.get(\"apple\")) {\n  case (?1111) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"banana\")) {\n  case (?2222) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"pear\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n  switch (a.get(\"avocado\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n\n  // undo operations above:\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n\n  // test fromEntries method\n  let c = H.fromEntries<Text, Nat>(b.entries(), Text.equal, Text.hash);\n\n  // c agrees with each entry of b\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (c.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // b agrees with each entry of c\n  for ((k,v) in c.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n};\n"},"noneTest.mo":{"content":"import Array \"mo:base/Array\";\nimport None \"mo:base/None\";\nimport Debug \"mo:base/Debug\";\n\nDebug.print(\"None\");\n\ndo {\n  Debug.print(\"  impossible\");\n\n  func showNone(x : None) : Text {\n    None.impossible<Text>(x);\n  };\n};\n"},"RBTreeTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Nat \"mo:base/Nat\";\nimport I \"mo:base/Iter\";\nimport List \"mo:base/List\";\nimport RBT \"mo:base/RBTree\";\n\nlet sorted =\n  [\n    (1, \"reformer\"),\n    (2, \"helper\"),\n    (3, \"achiever\"),\n    (4, \"individualist\"),\n    (5, \"investigator\"),\n    (6, \"loyalist\"),\n    (7, \"enthusiast\"),\n    (8, \"challenger\"),\n    (9, \"peacemaker\"),\n  ];\n\nlet unsort =\n  [\n    (6, \"loyalist\"),\n    (3, \"achiever\"),\n    (9, \"peacemaker\"),\n    (1, \"reformer\"),\n    (4, \"individualist\"),\n    (2, \"helper\"),\n    (8, \"challenger\"),\n    (5, \"investigator\"),\n    (7, \"enthusiast\"),\n  ];\n\nvar t = RBT.RBTree<Nat, Text>(Nat.compare);\n\nassert RBT.size(t.share()) == 0;\n\nfor ((num, lab) in unsort.vals()) {\n  Debug.print (Nat.toText num);\n  Debug.print lab;\n  t.put(num, lab);\n};\n\ndo { var i = 1;\nfor ((num, lab) in t.entries()) {\n  assert(num == i);\n i += 1;\n}};\n\nassert RBT.size(t.share()) == 9;\n\ndo { var i = 9;\nfor ((num, lab) in t.entriesRev()) {\n  assert(num == i);\n  i -= 1;\n}};\n\nassert RBT.size(t.share()) == 9;\n\nt.delete(5);\n\nassert RBT.size(t.share()) == 8;\n"},"charTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Char \"mo:base/Char\";\nimport Prim \"mo:⛔\";\n\n/*\n//\n// Char.toUpper\n//\n\nassert(Char.toUpper('ö') == 'Ö');\nassert(Char.toUpper('σ') == 'Σ');\nassert(Char.toUpper('💩') == '💩');\n\n//\n// Char.toLower\n//\n\nassert(Char.toLower('Ö') == 'ö');\nassert(Char.toLower('Σ') == 'σ');\nassert(Char.toLower('💩') == '💩');\n*/\n\n//\n// Char.isWhitespace\n//\n\nassert(Char.isWhitespace(' '));\n\nassert(not Char.isWhitespace('x'));\n\n// 12288 (U+3000) = ideographic space\nassert(Char.isWhitespace(Prim.nat32ToChar(12288)));\n\nassert(Char.isWhitespace('\\t'));\n\n// Vertical tab ('\\v')\nassert(Char.isWhitespace(Prim.nat32ToChar(0x0B)));\n\n// Form feed ('\\f')\nassert(Char.isWhitespace(Prim.nat32ToChar(0x0C)));\n\nassert(Char.isWhitespace('\\r'));\n\n//\n// Char.isLowercase\n//\n\nassert(Char.isLowercase('x'));\nassert(not Char.isLowercase('X'));\n\n//\n// Char.isUppercase\n//\n\nassert(Char.isUppercase('X'));\nassert(not Char.isUppercase('x'));\n\n//\n// Char.isAlphabetic\n//\n\nassert(Char.isAlphabetic('a'));\nassert(Char.isAlphabetic('京'));\nassert(not Char.isAlphabetic('㋡'));\n"},"intTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Int \"mo:base/Int\";\n\nDebug.print(\"Int\");\n\ndo {\n  Debug.print(\"  add\");\n\n  assert(Int.add(1, Int.add(2, 3)) == Int.add(1, Int.add(2, 3)));\n  assert(Int.add(0, 1) == 1);\n  assert(1 == Int.add(1, 0));\n  assert(Int.add(0, 1) == Int.add(1, 0));\n  assert(Int.add(1, 2) == Int.add(2, 1));\n};\n\ndo {\n  Debug.print(\"  toText\");\n\n  assert(Int.toText(0) == \"0\");\n  assert(Int.toText(-0) == \"0\");\n  assert(Int.toText(1234) == \"1234\");\n  assert(Int.toText(-1234) == \"-1234\");\n};\n"},"trieSetTest.mo":{"content":"import Nat \"mo:base/Nat\";\nimport TrieSet \"mo:base/TrieSet\";\nimport Nat32 \"mo:base/Nat32\";\nimport Hash \"mo:base/Hash\";\nimport Suite \"mo:matchers/Suite\";\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\n\nlet simpleTests = do {\n  let set1 = TrieSet.fromArray<Nat>([ 1, 2, 3, 1, 2, 3, 1 ], Nat32.fromNat, Nat.equal);\n\n  let suite = Suite.suite(\"TrieSet fromArray\", [\n    Suite.test(\n      \"mem\",\n      TrieSet.mem<Nat>(set1, 1, 1, Nat.equal),\n      M.equals(T.bool true)\n    ),\n    Suite.test(\n      \"size\",\n      TrieSet.size(set1),\n      M.equals(T.nat 3)\n    ),\n    Suite.test(\n      \"toArray\",\n      TrieSet.toArray<Nat>(set1),\n      M.equals(T.array<Nat>(T.natTestable, [ 1, 2, 3 ]))\n    )\n  ]);\n  Suite.run(suite);\n};\n\nlet binopTests = do {\n  let a = TrieSet.fromArray<Nat>([1, 3], Hash.hash, Nat.equal);\n  let b = TrieSet.fromArray<Nat>([2, 3], Hash.hash, Nat.equal);\n\n  let suite = Suite.suite(\"TrieSet -- binary operations\", [\n    Suite.test(\"union\",\n      TrieSet.toArray(TrieSet.union(a, b, Nat.equal)),\n      M.equals(T.array<Nat>(T.natTestable, [1, 2, 3]))\n    ),\n    Suite.test(\"intersect\",\n      TrieSet.toArray(TrieSet.intersect(a, b, Nat.equal)),\n      M.equals(T.array<Nat>(T.natTestable, [3]))\n    ),\n    Suite.test(\"diff\",\n      TrieSet.toArray(TrieSet.diff(a, b, Nat.equal)),\n      M.equals(T.array<Nat>(T.natTestable, [1]))\n    ),\n  ]);\n  Suite.run(suite);\n};\n\n"},"heapTest.mo":{"content":"import H \"mo:base/Heap\";\nimport I \"mo:base/Iter\";\nimport O \"mo:base/Option\";\nimport Int \"mo:base/Int\";\n\nlet order = Int.compare;\n\ndo {\n    var pq = H.Heap<Int>(order);\n    for (i in I.revRange(100, 0)) {\n        pq.put(i);\n        let x = pq.peekMin();\n        assert(O.unwrap(x) == i);\n    };\n    for (i in I.range(0, 100)) {\n        pq.put(i);\n        let x = pq.peekMin();\n        assert(O.unwrap(x) == 0);\n    };\n    for (i in I.range(0, 100)) {\n        pq.deleteMin();\n        let x = pq.peekMin();\n        pq.deleteMin();\n        assert(O.unwrap(x) == i);\n    };\n    O.assertNull(pq.peekMin());\n};\n\n// fromIter\ndo {\n    do {\n        let iter = [5,10,9,7,3,8,1,0,2,4,6].vals();\n        let pq = H.fromIter<Int>(iter, order);\n        for (i in I.range(0, 10)) {\n            let x = pq.peekMin();\n            assert(O.unwrap(x) == i);\n            pq.deleteMin();\n        };\n        O.assertNull(pq.peekMin());\n    };\n\n    do {\n        let pq = H.fromIter<Int>([].vals(), order);\n        O.assertNull(pq.peekMin());\n    };\n\n    do {\n        let pq = H.fromIter<Int>([100].vals(), order);\n        assert(O.unwrap(pq.peekMin()) == 100);\n    };\n};\n"},"listTest.mo":{"content":"import List \"mo:base/List\";\nimport Debug \"mo:base/Debug\";\nimport Int \"mo:base/Int\";\nimport Iter \"mo:base/Iter\";\nimport Result \"mo:base/Result\";\nimport Suite \"mo:matchers/Suite\";\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\n\n\ntype X = Nat;\n\n  func opnatEq(a : ?Nat, b : ?Nat) : Bool {\n    switch (a, b) {\n    case (null, null) { true };\n    case (?aaa, ?bbb) { aaa == bbb };\n    case (_,    _   ) { false };\n    }\n  };\n  func opnat_isnull(a : ?Nat) : Bool {\n    switch a {\n    case (null) { true };\n    case (?aaa) { false };\n    }\n  };\n\n  // ## Construction\n  let l1 = List.nil<X>();\n  let l2 = List.push<X>(2, l1);\n  let l3 = List.push<X>(3, l2);\n\n  // ## Projection -- use nth\n  assert (opnatEq(List.get<X>(l3, 0), ?3));\n  assert (opnatEq(List.get<X>(l3, 1), ?2));\n  assert (opnatEq(List.get<X>(l3, 2), null));\n  //assert (opnatEq (hd<X>(l3), ?3));\n  //assert (opnatEq (hd<X>(l2), ?2));\n  //assert (opnat_isnull(hd<X>(l1)));\n\n  /*\n   // ## Projection -- use nth\n   assert (opnatEq(nth<X>(l3, 0), ?3));\n   assert (opnatEq(nth<X>(l3, 1), ?2));\n   assert (opnatEq(nth<X>(l3, 2), null));\n   assert (opnatEq (hd<X>(l3), ?3));\n   assert (opnatEq (hd<X>(l2), ?2));\n   assert (opnat_isnull(hd<X>(l1)));\n   */\n\n  // ## Deconstruction\n  let (a1, t1) = List.pop<X>(l3);\n  assert (opnatEq(a1, ?3));\n  let (a2, t2) = List.pop<X>(l2);\n  assert (opnatEq(a2, ?2));\n  let (a3, t3) = List.pop<X>(l1);\n  assert (opnatEq(a3, null));\n  assert (List.isNil<X>(t3));\n\n  // ## List functions\n  assert (List.size<X>(l1) == 0);\n  assert (List.size<X>(l2) == 1);\n  assert (List.size<X>(l3) == 2);\n\n  // ## List functions\n  assert (List.size<X>(l1) == 0);\n  assert (List.size<X>(l2) == 1);\n  assert (List.size<X>(l3) == 2);\n\n  do {\n    Debug.print(\"  flatten\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, null)));\n    // [[1, 2], [3]]\n    let nested : List.List<List.List<Nat>> =\n      ?(?(1, ?(2, null)), ?(?(3, null), null));\n    let actual = List.flatten<Nat>(nested);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n\n  };\n\n  do {\n    Debug.print(\"  fromArray\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let array = [1, 2, 3];\n    let actual = List.fromArray<Nat>(array);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n  };\n\n  do {\n    Debug.print(\"  fromVarArray\");\n\n    let expected : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let array = [var 1, 2, 3];\n    let actual = List.fromVarArray<Nat>(array);\n\n    assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n  };\n\n  do {\n    Debug.print(\"  toArray\");\n\n    let expected = [1, 2, 3];\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let actual = List.toArray<Nat>(list);\n\n    assert (actual.size() == expected.size());\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\n  do {\n    Debug.print(\"  toVarArray\");\n\n    let expected = [var 1, 2, 3];\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let actual = List.toVarArray<Nat>(list);\n\n    assert (actual.size() == expected.size());\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\n  do {\n    Debug.print(\"  toIter\");\n\n    let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n    let _actual = List.toIter<Nat>(list);\n    let actual = [var 0, 0, 0];\n    let expected = [1, 2, 3];\n\n    Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n    for (i in actual.keys()) {\n      assert(actual[i] == expected[i]);\n    };\n  };\n\nfunc makeNatural(x : Int) : Result.Result<Nat, Text> =\n  if (x >= 0) { #ok(Int.abs(x)) } else { #err(Int.toText(x) # \" is not a natural number.\") };\n\nfunc listRes(itm : Result.Result<List.List<Nat>, Text>) : T.TestableItem<Result.Result<List.List<Nat>, Text>> {\n  let resT = T.resultTestable(T.listTestable<Nat>(T.intTestable), T.textTestable);\n  { display = resT.display; equals = resT.equals; item = itm }\n};\n\nlet mapResult = Suite.suite(\"mapResult\", [\n  Suite.test(\"empty list\",\n    List.mapResult<Int, Nat, Text>(List.nil(), makeNatural),\n    M.equals(listRes(#ok(List.nil())))\n  ),\n  Suite.test(\"success\",\n    List.mapResult<Int, Nat, Text>(?(1, ?(2, ?(3, null))), makeNatural),\n    M.equals(listRes(#ok(?(1, ?(2, ?(3, null))))))\n  ),\n  Suite.test(\"fail fast\",\n    List.mapResult<Int, Nat, Text>(?(-1, ?(2, ?(3, null))), makeNatural),\n    M.equals(listRes(#err(\"-1 is not a natural number.\")))\n  ),\n  Suite.test(\"fail last\",\n    List.mapResult<Int, Nat, Text>(?(1, ?(2, ?(-3, null))), makeNatural),\n    M.equals(listRes(#err(\"-3 is not a natural number.\")))\n  ),\n]);\n\nSuite.run(Suite.suite(\"List\", [ mapResult ]));\n\nlet replicate = Suite.suite(\"replicate\", [\n  Suite.test(\"empty-list\",\n    List.replicate<Nat>(0, 0),\n    M.equals(\n      T.list(T.natTestable, List.nil<Nat>()))\n  ),\n  Suite.test(\"small-list\",\n    List.replicate(3, 0),\n    M.equals(\n      T.list<Nat>(T.natTestable, ?(0, ?(0, ?(0, null)))))\n  )\n]);\n\nlet tabulate = Suite.suite(\"tabulate\", [\n  Suite.test(\"empty-list\",\n    List.tabulate<Nat>(0, func i { i }),\n    M.equals(\n      T.list(T.natTestable, List.nil<Nat>()))\n  ),\n  Suite.test(\"small-list\",\n    List.tabulate<Nat>(3, func i { i * 2 }),\n    M.equals(\n      T.list<Nat>(T.natTestable, ?(0, ?(2, ?(4, null)))))\n  ),\n  Suite.test(\"large-list\",\n    List.tabulate<Nat>(10000, func i { 0 }),\n    M.equals(\n      T.list<Nat>(T.natTestable, List.replicate(10000, 0)))\n  )\n]);\n\nlet append = Suite.suite(\"append\", [\n  Suite.test(\"small-list\",\n    List.append(\n      List.tabulate<Nat>(10, func i { i }),\n      List.tabulate<Nat>(10, func i { i + 10 })),\n    M.equals(\n      T.list(T.natTestable, List.tabulate<Nat>(20, func i { i })))\n  ),\n  Suite.test(\"large-list\",\n    List.append(\n      List.tabulate<Nat>(10000, func i { i }),\n      List.tabulate<Nat>(10000, func i { i + 10000 })),\n    M.equals(\n      T.list(T.natTestable,List.tabulate<Nat>(20000, func i { i })))\n  ),\n]);\n\nSuite.run(Suite.suite(\"List\", [ mapResult, replicate, tabulate, append ]));\n"},"iterTest.mo":{"content":"import Iter \"mo:base/Iter\";\nimport Array \"mo:base/Array\";\nimport List \"mo:base/List\";\nimport Nat \"mo:base/Nat\";\nimport Int \"mo:base/Int\";\nimport Debug \"mo:base/Debug\";\n\nDebug.print(\"Iter\");\n\ndo {\n  Debug.print(\"  range\");\n\n  let tests = [((0,-1), \"\", \"0-1\"), ((0,0), \"0\", \"0\"), ((0, 5), \"012345\", \"\"), ((5, 0), \"\", \"543210\")];\n  for ((range, expected, revExpected) in tests.vals()) {\n      var x = \"\";\n      for (i in Iter.range(range)) {\n          x := x # Nat.toText(i);\n      };\n      assert(x == expected);\n      x := \"\";\n      for (i in Iter.revRange(range)) {\n          x := x # Int.toText(i);\n      };\n      assert(x == revExpected);\n  };\n};\n\ndo {\n  Debug.print(\"  iterate\");\n\n  let xs = [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ];\n\n  var y = \"\";\n  var z = 0;\n\n  Iter.iterate<Text>(xs.vals(), func (x : Text, i : Nat) {\n    y := y # x;\n    z += i;\n  });\n\n  assert(y == \"abcdef\");\n  assert(z == 15);\n};\n\ndo {\n  Debug.print(\"  map\");\n\n  let isEven = func (x : Int) : Bool {\n    x % 2 == 0;\n  };\n\n  let _actual = Iter.map<Nat, Bool>([ 1, 2, 3 ].vals(), isEven);\n  let actual = [var true, false, true];\n  Iter.iterate<Bool>(_actual, func (x, i) { actual[i] := x; });\n\n  let expected = [false, true, false];\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  filter\");\n\n  let isOdd = func (x : Int) : Bool {\n    x % 2 == 1;\n  };\n\n  let _actual = Iter.filter<Nat>([ 1, 2, 3 ].vals(), isOdd);\n  let actual = [var 0, 0];\n  Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n  let expected = [1, 3];\n\n  assert(Array.freeze(actual) == expected);\n};\n\ndo {\n  Debug.print(\"  make\");\n\n  let x = 1;\n  let y = Iter.make<Nat>(x);\n\n  switch (y.next()) {\n    case null { assert false; };\n    case (?z) { assert (x == z); };\n  };\n};\n\ndo {\n  Debug.print(\"  fromArray\");\n\n  let expected = [1, 2, 3];\n  let _actual = Iter.fromArray<Nat>(expected);\n  let actual = [var 0, 0, 0];\n\n  Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  fromArrayMut\");\n\n  let expected = [var 1, 2, 3];\n  let _actual = Iter.fromArrayMut<Nat>(expected);\n  let actual = [var 0, 0, 0];\n\n  Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  fromList\");\n\n  let list : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n  let _actual = Iter.fromList<Nat>(list);\n  let actual = [var 0, 0, 0];\n  let expected = [1, 2, 3];\n\n  Iter.iterate<Nat>(_actual, func (x, i) { actual[i] := x; });\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  toArray\");\n\n  let expected = [1, 2, 3];\n  let actual = Iter.toArray<Nat>(expected.vals());\n\n  assert (actual.size() == expected.size());\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  toArrayMut\");\n\n  let expected = [var 1, 2, 3];\n  let actual = Iter.toArrayMut<Nat>(expected.vals());\n\n  assert (actual.size() == expected.size());\n\n  for (i in actual.keys()) {\n    assert(actual[i] == expected[i]);\n  };\n};\n\ndo {\n  Debug.print(\"  toList\");\n\n  let expected : List.List<Nat> = ?(1, ?(2, ?(3, List.nil<Nat>())));\n  let actual = Iter.toList<Nat>([1, 2, 3].vals());\n  assert List.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n};\n\n\ndo {\n  Debug.print(\"  sort\");\n\n  let input : [Nat] = [4, 3, 1, 2, 5];\n  let expected : [Nat] = [1, 2, 3, 4, 5];\n  let actual = Iter.toArray(Iter.sort<Nat>(input.vals(), Nat.compare));\n  assert Array.equal<Nat>(expected, actual, func (x1, x2) { x1 == x2 });\n};\n"},"stackTest.mo":{"content":"import Stack \"mo:base/Stack\";\nimport Iter \"mo:base/Iter\";\nimport O \"mo:base/Option\";\n\ndo {\n    var s = Stack.Stack<Nat>();\n    for (i in Iter.range(0, 100)) {\n        s.push(i);\n    };\n    for (i in Iter.revRange(100, 0)) {\n        let x = s.pop();\n        assert(O.unwrap(x) == i);\n    };\n    assert (s.isEmpty());\n};\n"},"hashMapTest.mo":{"content":"import Prim \"mo:⛔\";\nimport H \"mo:base/HashMap\";\nimport Hash \"mo:base/Hash\";\nimport Text \"mo:base/Text\";\n\ndebug {\n  let a = H.HashMap<Text, Nat>(3, Text.equal, Text.hash);\n\n  a.put(\"apple\", 1);\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n  a.put(\"Apple\", 11);\n  a.put(\"Banana\", 22);\n  a.put(\"Pear\", 33);\n  a.put(\"Avocado\", 44);\n  a.put(\"ApplE\", 111);\n  a.put(\"BananA\", 222);\n  a.put(\"PeaR\", 333);\n  a.put(\"AvocadO\", 444);\n\n  // need to resupply the constructor args; they are private to the object; but, should they be?\n  let b = H.clone<Text, Nat>(a, Text.equal, Text.hash);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure clone has each key present in original\n  for (k in a.keys()) {\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?_) {  };\n    };\n  };\n\n  // ensure clone has each value present in original\n  for (v in a.vals()) {\n    var foundMatch = false;\n    for (w in b.vals()) {\n      if (v == w) { foundMatch := true }\n    };\n    assert foundMatch\n  };\n\n  // do some more operations:\n  a.put(\"apple\", 1111);\n  a.put(\"banana\", 2222);\n  switch( a.remove(\"pear\")) {\n    case null { assert false };\n    case (?three) { assert three == 3 };\n  };\n  a.delete(\"avocado\");\n\n  // check them:\n  switch (a.get(\"apple\")) {\n  case (?1111) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"banana\")) {\n  case (?2222) { };\n  case _ { assert false };\n  };\n  switch (a.get(\"pear\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n  switch (a.get(\"avocado\")) {\n  case null {  };\n  case (?_) { assert false };\n  };\n\n  // undo operations above:\n  a.put(\"apple\", 1);\n  // .. and test that replace works\n  switch (a.replace(\"apple\", 666)) {\n    case null { assert false };\n    case (?one) { assert one == 1; // ...and revert\n                  a.put(\"apple\", 1)\n         };\n  };\n  a.put(\"banana\", 2);\n  a.put(\"pear\", 3);\n  a.put(\"avocado\", 4);\n\n  // ensure clone has each key-value pair present in original\n  for ((k,v) in a.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // ensure original has each key-value pair present in clone\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (a.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n\n  // test fromIter method\n  let c = H.fromIter<Text, Nat>(b.entries(), 0, Text.equal, Text.hash);\n\n  // c agrees with each entry of b\n  for ((k,v) in b.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (c.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // b agrees with each entry of c\n  for ((k,v) in c.entries()) {\n    Prim.debugPrint(debug_show (k,v));\n    switch (b.get(k)) {\n    case null { assert false };\n    case (?w) { assert v == w };\n    };\n  };\n\n  // Issue #228\n  let d = H.HashMap<Text, Nat>(50, Text.equal, Text.hash);\n  switch(d.remove(\"test\")) {\n    case null { };\n    case (?_) { assert false };\n  };\n};\n"},"textTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Text \"mo:base/Text\";\nimport Blob \"mo:base/Blob\";\nimport Iter \"mo:base/Iter\";\nimport Char \"mo:base/Char\";\nimport Order \"mo:base/Order\";\nimport Array \"mo:base/Array\";\nimport Nat32 \"mo:base/Nat32\";\n\nimport Suite \"mo:matchers/Suite\";\nimport M \"mo:matchers/Matchers\";\nimport T \"mo:matchers/Testable\";\n\nlet {run;test;suite} = Suite;\n\nfunc charT(c : Char): T.TestableItem<Char> = {\n  item = c;\n  display = Text.fromChar;\n  equals = Char.equal;\n};\n\nfunc blobT(b : Blob): T.TestableItem<Blob> = {\n  item = b;\n  display = func(b : Blob) : Text { debug_show(b) };\n  equals = Blob.equal;\n};\n\nfunc ordT(o : Order.Order): T.TestableItem<Order.Order> = {\n  item = o;\n  display = func (o : Order.Order) : Text { debug_show(o) };\n  equals = Order.equal;\n};\n\nfunc optTextT(ot : ?Text): T.TestableItem<?Text> = T.optional(T.textTestable, ot);\n\n// TODO: generalize and move to Iter.mo\nfunc iterT(c : [Char]): T.TestableItem<Iter.Iter<Char>> = {\n  item = c.vals();\n  display = Text.fromIter; // not this will only print the remainder of cs1 below\n  equals = func (cs1 : Iter.Iter<Char>, cs2 : Iter.Iter<Char>) : Bool {\n     loop {\n       switch (cs1.next(), cs2.next()) {\n         case (null,null) return true;\n         case (? c1, ? c2)\n           if (c1 != c2) return false;\n         case (_, _) return false;\n       }\n     }\n  };\n};\n\n// TODO: generalize and move to Iter.mo\nfunc textIterT(c : [Text]): T.TestableItem<Iter.Iter<Text>> = {\n  item = c.vals();\n  display = func (ts: Iter.Iter<Text>) : Text { Text.join(\",\", ts) };\n     // not this will only print the remainder of cs1 below\n  equals = func (ts1 : Iter.Iter<Text>, ts2 : Iter.Iter<Text>) : Bool {\n     loop {\n       switch (ts1.next(), ts2.next()) {\n         case (null,null) return true;\n         case (? t1, ? t2)\n           if (t1 != t2) return false;\n         case (_, _) return false;\n       }\n     }\n  };\n};\n\n\nrun(suite(\"size\",\n[\n test(\n   \"size-0\",\n   Text.size(\"\"),\n   M.equals(T.nat 0)),\n test(\n   \"size-1\",\n   Text.size(\"a\"),\n   M.equals(T.nat 1)),\n test(\n   \"size-2\",\n   Text.size(\"abcdefghijklmnopqrstuvwxyz\"),\n   M.equals(T.nat 26)),\n test(\n   \"size-3\",\n   Text.size(\"☃\"),\n   M.equals(T.nat 1)),\n test(\n   \"size-4\",\n   Text.size(\"☃☃\"),\n   M.equals(T.nat 2)),\n]));\n\n\n\nrun(suite(\"toIter\",\n[\n test(\n   \"toIter-0\",\n   Text.toIter(\"\"),\n   M.equals(iterT([]))),\n test(\n   \"toIter-1\",\n   Text.toIter(\"a\"),\n   M.equals(iterT (['a']))),\n test(\n   \"toIter-2\",\n   Text.toIter(\"abc\"),\n   M.equals(iterT (['a','b','c']))),\n do {\n   let a = Array.tabulate<Char>(1000, func i = Char.fromNat32(65+%Nat32.fromIntWrap(i % 26)));\n   test(\n     \"fromIter-2\",\n     Text.toIter(Text.join(\"\", Array.map(a, Char.toText).vals())),\n     M.equals(iterT a))\n },\n]));\n\nrun(suite(\"fromIter\",\n[\n test(\n   \"fromIter-0\",\n   Text.fromIter(([].vals())),\n   M.equals(T.text(\"\"))),\n test(\n   \"fromIter-1\",\n   Text.fromIter((['a'].vals())),\n   M.equals(T.text \"a\")),\n test(\n   \"fromIter-2\",\n   Text.fromIter((['a', 'b', 'c'].vals())),\n   M.equals(T.text \"abc\")),\n do {\n   let a = Array.tabulate<Char>(1000, func i = Char.fromNat32(65+%Nat32.fromIntWrap(i % 26)));\n   test(\n   \"fromIter-3\",\n   Text.fromIter(a.vals()),\n   M.equals(T.text (Text.join(\"\", Array.map(a, Char.toText).vals()))))\n },\n]));\n\n\nrun(suite(\"concat\",\n[\n test(\n   \"concat-0\",\n   Text.concat(\"\",\"\"),\n   M.equals(T.text(\"\"))),\n test(\n   \"concat-1\",\n   Text.concat(\"\",\"b\"),\n   M.equals(T.text \"b\")),\n test(\n   \"concat-2\",\n   Text.concat(\"a\",\"b\"),\n   M.equals(T.text \"ab\")),\n test(\n   \"concat-3\",\n   Text.concat(\"abcdefghijklmno\",\"pqrstuvwxyz\"),\n   M.equals(T.text \"abcdefghijklmnopqrstuvwxyz\")),\n]));\n\nrun(suite(\"join\",\n[\n test(\n   \"join-0\",\n   Text.join(\"\", ([\"\",\"\"].vals())),\n   M.equals(T.text(\"\"))),\n test(\n   \"join-1\",\n   Text.join(\"\", ([\"\",\"b\"].vals())),\n   M.equals(T.text \"b\")),\n test(\n   \"join-2\",\n   Text.join(\"\", ([\"a\",\"bb\",\"ccc\",\"dddd\"].vals())),\n   M.equals(T.text \"abbcccdddd\")),\n do {\n   let a = Array.tabulate<Char>(1000, func i = Char.fromNat32(65+%Nat32.fromIntWrap(i % 26)));\n   test(\n   \"join-3\",\n   Text.join(\"\", Array.map(a, Char.toText).vals()),\n   M.equals(T.text (Text.fromIter(a.vals()))))\n },\n test(\n   \"join-4\",\n   Text.join(\"\", ([].vals())),\n   M.equals(T.text \"\")),\n test(\n   \"join-5\",\n   Text.join(\"\", ([\"aaa\"].vals())),\n   M.equals(T.text \"aaa\")),\n]));\n\nrun(suite(\"join\",\n[\n test(\n   \"join-0\",\n   Text.join(\",\", ([\"\",\"\"].vals())),\n   M.equals(T.text(\",\"))),\n test(\n   \"join-1\",\n   Text.join(\",\", ([\"\",\"b\"].vals())),\n   M.equals(T.text \",b\")),\n test(\n   \"join-2\",\n   Text.join(\",\", ([\"a\",\"bb\",\"ccc\",\"dddd\"].vals())),\n   M.equals(T.text \"a,bb,ccc,dddd\")),\n do {\n   let a = Array.tabulate<Char>(1000, func i = Char.fromNat32(65+%Nat32.fromIntWrap(i % 26)));\n   test(\n   \"join-3\",\n   Text.join(\"\", Array.map(a, Char.toText).vals()),\n   M.equals(T.text (Text.fromIter(a.vals()))))\n  },\n test(\n   \"join-4\",\n   Text.join(\",\", ([].vals())),\n   M.equals(T.text \"\")),\n test(\n   \"join-5\",\n   Text.join(\",\", ([\"aaa\"].vals())),\n   M.equals(T.text \"aaa\")),\n]));\n\n\nrun(suite(\"split\",\n[\n test(\n   \"split-char-empty\",\n   Text.split(\"\", #char ';'),\n   M.equals(textIterT([]))),\n test(\n   \"split-char-none\",\n   Text.split(\"abc\", #char ';'),\n   M.equals(textIterT([\"abc\"]))),\n test(\n   \"split-char-empties2\",\n   Text.split(\";\", #char ';'),\n   M.equals(textIterT([\"\",\"\"]))),\n test(\n   \"split-char-empties3\",\n   Text.split(\";;\", #char ';'),\n   M.equals(textIterT([\"\",\"\",\"\"]))),\n test(\n   \"split-char-singles\",\n   Text.split(\"a;b;;c;;;d\", #char ';'),\n   M.equals(textIterT([\"a\",\"b\",\"\",\"c\",\"\",\"\",\"d\"]))),\n test(\n   \"split-char-mixed\",\n   Text.split(\"a;;;ab;;abc;\", #char ';'),\n   M.equals(textIterT([\"a\",\"\",\"\",\"ab\",\"\",\"abc\",\"\"]))),\n do {\n   let a = Array.tabulate<Text>(1000,func _ = \"abc\");\n   let t = Text.join(\";\", a.vals());\n   test(\n     \"split-char-large\",\n     Text.split(t, #char ';'),\n     M.equals(textIterT a))\n },\n do {\n   let a = Array.tabulate<Text>(100000,func _ = \"abc\");\n   let t = Text.join(\";\", a.vals());\n   test(\n     \"split-char-very-large\",\n     Text.split(t, #char ';'),\n     M.equals(textIterT a))\n },\n]));\n\n\ndo {\nlet pat : Text.Pattern = #predicate (func (c : Char) : Bool { c == ';' or c == '!' }) ;\nrun(suite(\"split\",\n[\n test(\n   \"split-pred-empty\",\n   Text.split(\"\", pat),\n   M.equals(textIterT([]))),\n test(\n   \"split-pred-none\",\n   Text.split(\"abc\", pat),\n   M.equals(textIterT([\"abc\"]))),\n test(\n   \"split-pred-empties2\",\n   Text.split(\";\", pat),\n   M.equals(textIterT([\"\",\"\"]))),\n test(\n   \"split-pred-empties3\",\n   Text.split(\";!\", pat),\n   M.equals(textIterT([\"\",\"\",\"\"]))),\n test(\n   \"split-pred-singles\",\n   Text.split(\"a;b;!c!;;d\", pat),\n   M.equals(textIterT([\"a\",\"b\",\"\",\"c\",\"\",\"\",\"d\"]))),\n test(\n   \"split-pred-mixed\",\n   Text.split(\"a;!;ab;!abc;\", pat),\n   M.equals(textIterT([\"a\",\"\",\"\",\"ab\",\"\",\"abc\",\"\"]))),\n do {\n   let a = Array.tabulate<Text>(1000,func _ = \"abc\");\n   let t = Text.join(\";\", a.vals());\n   test(\n     \"split-pred-large\",\n     Text.split(t, pat),\n     M.equals(textIterT a))\n },\n do {\n   let a = Array.tabulate<Text>(10000,func _ = \"abc\");\n   let t = Text.join(\";\", a.vals());\n   test(\n     \"split-pred-very-large\",\n     Text.split(t, pat),\n     M.equals(textIterT a))\n },\n]))\n};\n\n\ndo {\nlet pat : Text.Pattern = #text \"PAT\" ;\nrun(suite(\"split\",\n[\n test(\n   \"split-pat-empty\",\n   Text.split(\"\", pat),\n   M.equals(textIterT([]))),\n test(\n   \"split-pat-none\",\n   Text.split(\"abc\", pat),\n   M.equals(textIterT([\"abc\"]))),\n test(\n   \"split-pat-empties2\",\n   Text.split(\"PAT\", pat),\n   M.equals(textIterT([\"\",\"\"]))),\n test(\n   \"split-pat-empties3\",\n   Text.split(\"PATPAT\", pat),\n   M.equals(textIterT([\"\",\"\",\"\"]))),\n test(\n   \"split-pat-singles\",\n   Text.split(\"aPATbPATPATcPATPATPATd\", pat),\n   M.equals(textIterT([\"a\",\"b\",\"\",\"c\",\"\",\"\",\"d\"]))),\n test(\n   \"split-pat-mixed\",\n   Text.split(\"aPATPATPATabPATPATabcPAT\", pat),\n   M.equals(textIterT([\"a\",\"\",\"\",\"ab\",\"\",\"abc\",\"\"]))),\n do {\n   let a = Array.tabulate<Text>(1000,func _ = \"abc\");\n   let t = Text.join(\"PAT\", a.vals());\n   test(\n     \"split-pat-large\",\n     Text.split(t, pat),\n     M.equals(textIterT a))\n },\n do {\n   let a = Array.tabulate<Text>(10000,func _ = \"abc\");\n   let t = Text.join(\"PAT\", a.vals());\n   test(\n     \"split-pat-very-large\",\n     Text.split(t, pat),\n     M.equals(textIterT a))\n },\n]))\n};\n\n\nrun(suite(\"tokens\",\n[\n test(\n   \"tokens-char-empty\",\n   Text.tokens(\"\", #char ';'),\n   M.equals(textIterT([]))),\n test(\n   \"tokens-char-none\",\n   Text.tokens(\"abc\", #char ';'),\n   M.equals(textIterT([\"abc\"]))),\n test(\n   \"tokens-char-empties2\",\n   Text.tokens(\";\", #char ';'),\n   M.equals(textIterT([]))),\n test(\n   \"tokens-char-empties3\",\n   Text.tokens(\";;\", #char ';'),\n   M.equals(textIterT([]))),\n test(\n   \"tokens-char-singles\",\n   Text.tokens(\"a;b;;c;;;d\", #char ';'),\n   M.equals(textIterT([\"a\",\"b\",\"c\",\"d\"]))),\n test(\n   \"tokens-char-mixed\",\n   Text.tokens(\"a;;;ab;;abc;\", #char ';'),\n   M.equals(textIterT([\"a\",\"ab\",\"abc\"]))),\n do {\n   let a = Array.tabulate<Text>(1000,func _ = \"abc\");\n   let t = Text.join(\";;\", a.vals());\n   test(\n     \"tokens-char-large\",\n     Text.tokens(t, #char ';'),\n     M.equals(textIterT a))\n },\n do {\n   let a = Array.tabulate<Text>(100000,func _ = \"abc\");\n   let t = Text.join(\";;\", a.vals());\n   test(\n     \"tokens-char-very-large\",\n     Text.tokens(t, #char ';'),\n     M.equals(textIterT a))\n },\n]));\n\nrun(suite(\"startsWith\",\n[\n test(\n   \"startsWith-both-empty\",\n   Text.startsWith(\"\", #text \"\"),\n   M.equals(T.bool true)),\n test(\n   \"startsWith-empty-text\",\n   Text.startsWith(\"\", #text \"abc\"),\n   M.equals(T.bool false)),\n test(\n   \"startsWith-empty-pat\",\n   Text.startsWith(\"abc\", #text \"\"),\n   M.equals(T.bool true)),\n test(\n   \"startsWith-1\",\n   Text.startsWith(\"a\", #text \"b\"),\n   M.equals(T.bool false)),\n test(\n   \"startsWith-2\",\n   Text.startsWith(\"abc\", #text \"abc\"),\n   M.equals(T.bool true)),\n test(\n   \"startsWith-3\",\n   Text.startsWith(\"abcd\", #text \"ab\"),\n   M.equals(T.bool true)),\n test(\n   \"startsWith-4\",\n   Text.startsWith(\"abcdefghijklmnopqrstuvwxyz\",#text \"abcdefghijklmno\"),\n   M.equals(T.bool true)),\n]));\n\n\n\nrun(suite(\"endsWith\",\n[\n test(\n   \"endsWith-both-empty\",\n   Text.endsWith(\"\", #text \"\"),\n   M.equals(T.bool true)),\n test(\n   \"endsWith-empty-text\",\n   Text.endsWith(\"\", #text \"abc\"),\n   M.equals(T.bool false)),\n test(\n   \"endsWith-empty-pat\",\n   Text.endsWith(\"abc\", #text \"\"),\n   M.equals(T.bool true)),\n test(\n   \"endsWith-1\",\n   Text.endsWith(\"a\", #text \"b\"),\n   M.equals(T.bool false)),\n test(\n   \"endsWith-2\",\n   Text.endsWith(\"abc\", #text \"abc\"),\n   M.equals(T.bool true)),\n test(\n   \"endsWith-3\",\n   Text.endsWith(\"abcd\", #text \"cd\"),\n   M.equals(T.bool true)),\n test(\n   \"endsWith-4\",\n   Text.endsWith(\"abcdefghijklmnopqrstuvwxyz\",#text \"pqrstuvwxyz\"),\n   M.equals(T.bool true)),\n]));\n\n\nrun(suite(\"contains\",\n[\n test(\n   \"contains-start\",\n   Text.contains(\"abcd\", #text \"ab\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-empty\",\n   Text.contains(\"abc\", #text \"\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-false\",\n   Text.contains(\"ab\", #text \"bc\" ),\n   M.equals(T.bool false)),\n test(\n   \"contains-exact\",\n   Text.contains(\"abc\", #text \"abc\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-within\",\n   Text.contains(\"abcdefghijklmnopqrstuvwxyz\", #text \"qrst\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-front\",\n   Text.contains(\"abcdefghijklmnopqrstuvwxyz\", #text \"abcdefg\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-end\",\n   Text.contains(\"abcdefghijklmnopqrstuvwxyz\", #text \"xyz\"),\n   M.equals(T.bool true)),\n test(\n   \"contains-false\",\n   Text.contains(\"abcdefghijklmnopqrstuvwxyz\", #text \"lkj\"),\n   M.equals(T.bool false)),\n test(\n   \"contains-empty-nonempty\",\n   Text.contains(\"\", #text \"xyz\"),\n   M.equals(T.bool false)),\n]));\n\n\nrun(suite(\"replace\",\n[\n test(\n   \"replace-start\",\n   Text.replace(\"abcd\", #text \"ab\", \"AB\"),\n   M.equals(T.text \"ABcd\")),\n test(\n   \"replace-empty\",\n   Text.replace(\"abc\", #text \"\", \"AB\"),\n   M.equals(T.text \"ABaABbABcAB\")),\n test(\n   \"replace-none\",\n   Text.replace(\"ab\", #text \"bc\", \"AB\"),\n   M.equals(T.text \"ab\")),\n test(\n   \"replace-exact\",\n   Text.replace(\"ab\", #text \"ab\", \"AB\"),\n   M.equals(T.text \"AB\")),\n test(\n   \"replace-several\",\n   Text.replace(\"abcdabghijabmnopqrstuabwxab\", #text \"ab\", \"AB\"),\n   M.equals(T.text \"ABcdABghijABmnopqrstuABwxAB\")),\n test(\n   \"replace-delete\",\n   Text.replace(\"abcdabghijabmnopqrstuabwxab\", #text \"ab\", \"\"),\n   M.equals(T.text \"cdghijmnopqrstuwx\")),\n test(\n   \"replace-pred\",\n   Text.replace(\"abcdefghijklmnopqrstuvwxyz\", #predicate (func (c : Char) : Bool { c < 'm'}), \"\"),\n   M.equals(T.text \"mnopqrstuvwxyz\")),\n test(\n  \"replace-partial\",\n  Text.replace(\"123\", #text \"124\", \"ABC\"),\n   M.equals(T.text \"123\")),\n test(\n  \"replace-partial-2\",\n  Text.replace(\"12341235124\", #text \"124\", \"ABC\"),\n   M.equals(T.text \"12341235ABC\")),\n test(\n  \"replace-partial-3\",\n  Text.replace(\"111234123511124\", #text \"124\", \"ABC\"),\n   M.equals(T.text \"111234123511ABC\")),\n]));\n\nrun(suite(\"stripStart\",\n[\n test(\n   \"stripStart-none\",\n   Text.stripStart(\"cd\", #text \"ab\"),\n   M.equals(optTextT (null))),\n test(\n   \"stripStart-one\",\n   Text.stripStart(\"abcd\", #text \"ab\"),\n   M.equals(optTextT (?\"cd\"))),\n test(\n   \"stripStart-two\",\n   Text.stripStart(\"abababcd\", #text \"ab\", ),\n   M.equals(optTextT (?\"ababcd\"))),\n test(\n   \"stripStart-only\",\n   Text.stripStart(\"ababababab\", #text \"ab\", ),\n   M.equals(optTextT (?\"abababab\"))),\n test(\n   \"stripStart-empty\",\n   Text.stripStart(\"abcdef\", #text \"\"),\n   M.equals(optTextT(?\"abcdef\"))),\n test(\n   \"stripStart-tooshort\",\n   Text.stripStart(\"abcdef\", #text \"abcdefg\"),\n   M.equals(optTextT(null))),\n]));\n\n\nrun(suite(\"stripEnd\",\n[\n test(\n   \"stripEnd-exact\",\n   Text.stripEnd(\"cd\", #text \"cd\"),\n   M.equals(optTextT (?\"\"))),\n test(\n   \"stripEnd-one\",\n   Text.stripEnd(\"abcd\", #text \"cd\"),\n   M.equals(optTextT (?\"ab\"))),\n test(\n   \"stripEnd-three\",\n   Text.stripEnd(\"abcdcdcd\", #text \"cd\", ),\n   M.equals(optTextT (?\"abcdcd\"))),\n test(\n   \"stripEnd-many\",\n   Text.stripEnd(\"cdcdcdcdcdcdcd\", #text \"cd\", ),\n   M.equals(optTextT (?\"cdcdcdcdcdcd\"))),\n test(\n   \"stripEnd-empty-pat\",\n   Text.stripEnd(\"abcdef\", #text \"\"),\n   M.equals(optTextT (?\"abcdef\"))),\n test(\n   \"stripEnd-empty\",\n   Text.stripEnd(\"\", #text \"cd\"),\n   M.equals(optTextT null)),\n test(\n   \"stripEnd-tooshort\",\n   Text.stripEnd(\"bcdef\", #text \"abcdef\"),\n   M.equals(optTextT null)),\n]));\n\n\nrun(suite(\"trimStart\",\n[\n test(\n   \"trimStart-none\",\n   Text.trimStart(\"cd\", #text \"ab\"),\n   M.equals(T.text \"cd\")),\n test(\n   \"trimStart-one\",\n   Text.trimStart(\"abcd\", #text \"ab\"),\n   M.equals(T.text \"cd\")),\n test(\n   \"trimStart-two\",\n   Text.trimStart(\"abababcd\", #text \"ab\", ),\n   M.equals(T.text \"cd\")),\n test(\n   \"trimStart-only\",\n   Text.trimStart(\"ababababab\", #text \"ab\", ),\n   M.equals(T.text \"\")),\n test(\n   \"trimStart-empty\",\n   Text.trimStart(\"abcdef\", #text \"\"),\n   M.equals(T.text \"abcdef\")),\n]));\n\nrun(suite(\"trimEnd\",\n[\n test(\n   \"trimEnd-exact\",\n   Text.trimEnd(\"cd\", #text \"cd\"),\n   M.equals(T.text \"\")),\n test(\n   \"trimEnd-one\",\n   Text.trimEnd(\"abcd\", #text \"cd\"),\n   M.equals(T.text \"ab\")),\n test(\n   \"trimEnd-three\",\n   Text.trimEnd(\"abcdcdcd\", #text \"cd\", ),\n   M.equals(T.text \"ab\")),\n test(\n   \"trimEnd-many\",\n   Text.trimEnd(\"cdcdcdcdcdcdcd\", #text \"cd\", ),\n   M.equals(T.text \"\")),\n test(\n   \"trimEnd-empty-pat\",\n   Text.trimEnd(\"abcdef\", #text \"\"),\n   M.equals(T.text \"abcdef\")),\n test(\n   \"trimEnd-empty\",\n   Text.trimEnd(\"\", #text \"cd\"),\n   M.equals(T.text \"\")),\n]));\n\nrun(suite(\"trim\",\n[\n test(\n   \"trim-exact\",\n   Text.trim(\"cd\", #text \"cd\"),\n   M.equals(T.text \"\")),\n test(\n   \"trim-one\",\n   Text.trim(\"cdabcd\", #text \"cd\"),\n   M.equals(T.text \"ab\")),\n  test(\n   \"trim-three\",\n   Text.trim(\"cdcdcdabcdcdcd\", #text \"cd\", ),\n   M.equals(T.text \"ab\")),\n test(\n   \"trim-many\",\n   Text.trim(\"cdcdcdcdcdcdcd\", #text \"cd\", ),\n   M.equals(T.text \"\")),\n test(\n   \"trim-empty-pat\",\n   Text.trim(\"abcdef\", #text \"\"),\n   M.equals(T.text \"abcdef\")),\n test(\n   \"trim-empty\",\n   Text.trim(\"\", #text \"cd\"),\n   M.equals(T.text \"\")),\n]));\n\nrun(suite(\"compare\",\n[\n test(\n   \"compare-empties\",\n   Text.compare(\"\", \"\"),\n   M.equals(ordT (#equal))),\n test(\n   \"compare-empty-nonempty\",\n   Text.compare(\"\", \"a\"),\n   M.equals(ordT (#less))),\n test(\n   \"compare-nonempty-empty\",\n   Text.compare(\"a\", \"\"),\n   M.equals(ordT (#greater))),\n test(\n   \"compare-a-a\",\n   Text.compare(\"a\", \"a\"),\n   M.equals(ordT (#equal))),\n test(\n   \"compare-a-b\",\n   Text.compare(\"a\", \"b\"),\n   M.equals(ordT (#less))),\n test(\n   \"compare-b-a\",\n   Text.compare(\"b\", \"a\"),\n   M.equals(ordT (#greater)))\n]));\n\ndo {\nlet cmp = Char.compare;\nrun(suite(\"compareWith\",\n[\n test(\n   \"compareWith-empties\",\n   Text.compareWith(\"\", \"\", cmp),\n   M.equals(ordT (#equal))),\n test(\n   \"compareWith-empty\",\n   Text.compareWith(\"abc\", \"\", cmp),\n   M.equals(ordT (#greater))),\n test(\n   \"compareWith-equal-nonempty\",\n   Text.compareWith(\"abc\", \"abc\", cmp ),\n   M.equals(ordT (#equal))),\n test(\n   \"compareWith-less-nonempty\",\n   Text.compareWith(\"abc\", \"abd\", cmp),\n   M.equals(ordT (#less))),\n test(\n   \"compareWith-less-nonprefix\",\n   Text.compareWith(\"abc\", \"abcd\", cmp),\n   M.equals(ordT (#less))),\n test(\n   \"compareWith-empty-nonempty\",\n   Text.compareWith(\"\", \"abcd\", cmp),\n   M.equals(ordT (#less))),\n test(\n   \"compareWith-prefix\",\n   Text.compareWith(\"abcd\", \"abc\", cmp),\n   M.equals(ordT (#greater)))\n]))\n};\n\ndo {\nlet cmp = func (c1 : Char, c2 : Char) : Order.Order {\n  switch (Char.compare (c1, c2)) {\n    case (#less) #greater;\n    case (#equal) #equal;\n    case (#greater) #less;\n  };\n};\nrun(suite(\"compareWith-flip\",\n[\n test(\n   \"compareWith-flip-greater\",\n   Text.compareWith(\"abc\", \"abd\", cmp),\n   M.equals(ordT (#greater))),\n test(\n   \"compareWith-flip-less\",\n   Text.compareWith(\"abd\", \"abc\", cmp),\n   M.equals(ordT (#less)))\n]))\n};\n\nrun(suite(\"utf8\",\n[\n test(\n   \"encode-literal\",\n   Text.encodeUtf8(\"FooBär☃\"),\n   M.equals(blobT(\"FooBär☃\"))),\n test(\n   \"encode-concat\",\n   Text.encodeUtf8(\"Foo\" # \"Bär\" # \"☃\"),\n   M.equals(blobT(\"FooBär☃\"))),\n test(\n   \"decode-literal-good\",\n   Text.decodeUtf8(\"FooBär☃\"),\n   M.equals(optTextT(?\"FooBär☃\"))),\n test(\n   \"decode-literal-bad1\",\n   Text.decodeUtf8(\"\\FF\"),\n   M.equals(optTextT(null))),\n test(\n   \"decode-literal-bad2\",\n   Text.decodeUtf8(\"\\D8\\00t d\"),\n   M.equals(optTextT(null))),\n]));\n"},"bufTest.mo":{"content":"import Prim \"mo:⛔\";\nimport B \"mo:base/Buffer\";\nimport Iter \"mo:base/Iter\";\nimport Option \"mo:base/Option\";\nimport Nat \"mo:base/Nat\";\nimport Hash \"mo:base/Hash\";\nimport Nat32 \"mo:base/Nat32\";\nimport Order \"mo:base/Order\";\n\nimport Suite \"mo:matchers/Suite\";\nimport T \"mo:matchers/Testable\";\nimport M \"mo:matchers/Matchers\";\n\nlet {run;test;suite} = Suite;\n\nlet NatBufferTestable : T.Testable<B.Buffer<Nat>> = object {\n  public func display(buffer : B.Buffer<Nat>) : Text {\n    B.toText(buffer, Nat.toText);\n  };\n  public func equals(buffer1 : B.Buffer<Nat>, buffer2 : B.Buffer<Nat>) : Bool {\n    B.equal(buffer1, buffer2, Nat.equal)\n  };\n};\n\nclass OrderTestable(initItem : Order.Order) : T.TestableItem<Order.Order> {\n  public let item = initItem;\n  public func display(order : Order.Order) : Text {\n    switch (order) {\n      case (#less) {\n        \"#less\"\n      };\n      case (#greater) {\n        \"#greater\"\n      };\n      case (#equal) {\n        \"#equal\"\n      }\n    }\n  };\n  public let equals = Order.equal;\n};\n\n/* --------------------------------------- */\nrun(suite(\"construct\",\n[\n  test(\n    \"initial size\",\n    B.Buffer<Nat>(10).size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"initial capacity\",\n    B.Buffer<Nat>(10).capacity(),\n    M.equals(T.nat(10))\n  ),\n]));\n\n/* --------------------------------------- */\n\nvar buffer = B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 3)) {\n  buffer.add(i);\n};\n\nrun(suite(\"add\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(4))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(10))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(2);\nfor (i in Iter.range(0, 3)) {\n  buffer.add(i);\n};\n\nrun(suite(\"add with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(4))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(0);\nfor (i in Iter.range(0, 3)) {\n  buffer.add(i);\n};\n\nrun(suite(\"add with capacity change, initial capacity 0\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(4))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(2);\n\nrun(suite(\"removeLast on empty buffer\",\n[\n  test(\n    \"return value\",\n    buffer.removeLast(),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(2);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nrun(suite(\"removeLast\",\n[\n  test(\n    \"return value\",\n    buffer.removeLast(),\n    M.equals(T.optional<Nat>(T.natTestable, ?5))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nfor (i in Iter.range(0, 5)) {\n  ignore buffer.removeLast();\n};\n\nrun(suite(\"removeLast until empty\",\n[\n  test(\n    \"return value\",\n    buffer.removeLast(),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(0);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nrun(suite(\"remove\",\n[\n  test(\n    \"return value\",\n    buffer.remove(2),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 3, 4, 5]))\n  ),\n  test(\n    \"return value\",\n    buffer.remove(0),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(4))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [1, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\nfor (i in Iter.range(0, 2)) {\n  buffer.add(i);\n};\n\nrun(suite(\"remove last element at capacity\",\n[\n  test(\n    \"return value\",\n    buffer.remove(2),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(0);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nfor (i in Iter.range(0, 5)) {\n  ignore buffer.remove(5 - i);\n};\n\nrun(suite(\"remove until empty\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(1);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.filterEntries(func(_, x) = x % 2 == 0);\n\nrun(suite(\"filterEntries\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 2, 4]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(1);\nbuffer.filterEntries(func(_, x) = x % 2 == 0);\n\nrun(suite(\"filterEntries on empty\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(12);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\nbuffer.filterEntries(func(i, x) = i + x == 2);\n\nrun(suite(\"filterEntries size down\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [1]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(5);\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i);\n};\nbuffer.filterEntries(func(_, _) = false);\n\nrun(suite(\"filterEntries size down to empty\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nrun(suite(\"get and getOpt\",\n[\n  test(\n    \"get\",\n    buffer.get(2),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"getOpt success\",\n    buffer.getOpt(0),\n    M.equals(T.optional(T.natTestable, ?0))\n  ),\n  test(\n    \"getOpt out of bounds\",\n    buffer.getOpt(10),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.put(2, 20);\n\nrun(suite(\"put\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 20, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\n\nbuffer.reserve(6);\n\nrun(suite(\"decrease capacity\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\n\nbuffer.reserve(20);\n\nrun(suite(\"increase capacity\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(20))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nvar buffer2 = B.Buffer<Nat>(20);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.append(buffer2);\n\nrun(suite(\"append\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(18))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(0);\n\nbuffer.append(buffer2);\n\nrun(suite(\"append empty buffer\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(10))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(10);\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(0, 5)) {\n  buffer2.add(i);\n};\n\nbuffer.append(buffer2);\n\nrun(suite(\"append to empty buffer\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(10))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.insert(3, 30);\n\nrun(suite(\"insert\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 30, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.insert(6, 60);\n\nrun(suite(\"insert at back\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 60]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.insert(0, 10);\n\nrun(suite(\"insert at front\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [10, 0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(6);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer.insert(3, 30);\n\nrun(suite(\"insert with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(9))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 30, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(5);\n\nbuffer.insert(0, 0);\n\nrun(suite(\"insert into empty buffer\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(0);\n\nbuffer.insert(0, 0);\n\nrun(suite(\"insert into empty buffer with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(15);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(3, buffer2);\n\nrun(suite(\"insertBuffer\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(15))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 10, 11, 12, 13, 14, 15, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(15);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(0, buffer2);\n\nrun(suite(\"insertBuffer at start\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(15))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(15);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(6, buffer2);\n\nrun(suite(\"insertBuffer at end\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(15))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(3, buffer2);\n\nrun(suite(\"insertBuffer with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(18))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 10, 11, 12, 13, 14, 15, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(0, buffer2);\n\nrun(suite(\"insertBuffer at start with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(18))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(8);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(6, buffer2);\n\nrun(suite(\"insertBuffer at end with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(12))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(18))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(7);\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(0, buffer2);\n\nrun(suite(\"insertBuffer to empty buffer\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [10, 11, 12, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nbuffer2 := B.Buffer<Nat>(10);\n\nfor (i in Iter.range(10, 15)) {\n  buffer2.add(i);\n};\n\nbuffer.insertBuffer(0, buffer2);\n\nrun(suite(\"insertBuffer to empty buffer with capacity change\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(9))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [10, 11, 12, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer.clear();\n\nrun(suite(\"clear\",\n[\n  test(\n    \"size\",\n    buffer.size(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.clone(buffer);\n\nrun(suite(\"clone\",\n[\n  test(\n    \"size\",\n    buffer2.size(),\n    M.equals(T.nat(buffer.size()))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(buffer2.capacity()))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, B.toArray(buffer2)))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nvar size = 0;\n\nfor (element in buffer.vals()) {\n  M.assertThat(element, M.equals(T.nat(size)));\n  size += 1;\n};\n\nrun(suite(\"vals\",\n[\n  test(\n    \"size\",\n    size,\n    M.equals(T.nat(7))\n  )\n]));\n\n/* --------------------------------------- */\nrun(suite(\"array round trips\",\n[\n  test(\n    \"fromArray and toArray\",\n    B.toArray<Nat>(B.fromArray<Nat>([0, 1, 2, 3])),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  ),\n  test(\n    \"fromVarArray\",\n    B.toArray<Nat>(B.fromVarArray<Nat>([var 0, 1, 2, 3])),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3]))\n  )\n]));\n\n/* --------------------------------------- */\nrun(suite(\"empty array round trips\",\n[\n  test(\n    \"fromArray and toArray\",\n    B.toArray<Nat>(B.fromArray<Nat>([])),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n  test(\n    \"fromVarArray\",\n    B.toArray<Nat>(B.fromVarArray<Nat>([var])),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i)\n};\n\nrun(suite(\"iter round trips\",\n[\n  test(\n    \"fromIter and vals\",\n    B.toArray(B.fromIter<Nat>(buffer.vals())),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 6]))\n  ),\n  test(\n    \"empty\",\n    B.toArray(B.fromIter<Nat>(B.Buffer<Nat>(2).vals())),\n    M.equals(T.array<Nat>(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nB.trimToSize(buffer);\n\nrun(suite(\"trimToSize\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(7))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 6]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nB.trimToSize(buffer);\n\nrun(suite(\"trimToSize on empty\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.map<Nat, Nat>(buffer, func x = x * 2);\n\nrun(suite(\"map\",\n[\n  test(\n    \"capacity\",\n    buffer2.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer2),\n    M.equals(T.array<Nat>(T.natTestable, [0, 2, 4, 6, 8, 10, 12]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(0);\n\nbuffer2 := B.map<Nat, Nat>(buffer, func x = x * 2);\n\nrun(suite(\"map empty\",\n[\n  test(\n    \"capacity\",\n    buffer2.capacity(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer2),\n    M.equals(T.array<Nat>(T.natTestable, []))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nvar sum = 0;\n\nB.iterate<Nat>(buffer, func x = sum += x);\n\nrun(suite(\"iterate\",\n[\n  test(\n    \"sum\",\n    sum,\n    M.equals(T.nat(21))\n  ),\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 2, 3, 4, 5, 6]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.chain<Nat, Nat>(buffer, func x = B.make<Nat> x);\n\nrun(suite(\"chain\",\n[\n  test(\n    \"elements\",\n    B.toArray(buffer2),\n    M.equals(T.array<Nat>(T.natTestable, B.toArray(buffer)))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.mapFilter<Nat, Nat>(buffer, func x = if (x % 2 == 0) { ?x } else { null });\n\nrun(suite(\"mapFilter\",\n[\n  test(\n    \"capacity\",\n    buffer2.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer2),\n    M.equals(T.array<Nat>(T.natTestable, [0, 2, 4, 6]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.mapEntries<Nat, Nat>(buffer, func (i, x) = i * x);\n\nrun(suite(\"mapEntries\",\n[\n  test(\n    \"capacity\",\n    buffer2.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer2),\n    M.equals(T.array<Nat>(T.natTestable, [0, 1, 4, 9, 16, 25, 36]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nvar bufferResult = B.mapResult<Nat, Nat, Text>(buffer, func x = #ok x);\n\nrun(suite(\"mapResult success\",\n[\n  test(\n    \"return value\",\n    #ok buffer,\n    M.equals(T.result<B.Buffer<Nat>, Text>(NatBufferTestable, T.textTestable, bufferResult))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nbufferResult := \n  B.mapResult<Nat, Nat, Text>(\n    buffer,\n    func x = if (x == 4) { #err \"error\"} else { #ok x }\n  );\n\nrun(suite(\"mapResult failure\",\n[\n  test(\n    \"return value\",\n    #err \"error\",\n    M.equals(T.result<B.Buffer<Nat>, Text>(NatBufferTestable, T.textTestable, bufferResult))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nrun(suite(\"foldLeft\",\n[\n  test(\n    \"return value\",\n    B.foldLeft<Text, Nat>(buffer, \"\", func(acc, x) = acc # Nat.toText(x)),\n    M.equals(T.text(\"0123456\"))\n  ),\n  test(\n    \"return value empty\",\n    B.foldLeft<Text, Nat>(B.Buffer<Nat>(4), \"\", func(acc, x) = acc # Nat.toText(x)),\n    M.equals(T.text(\"\"))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nrun(suite(\"foldRight\",\n[\n  test(\n    \"return value\",\n    B.foldRight<Nat, Text>(buffer, \"\", func(x, acc) = acc # Nat.toText(x)),\n    M.equals(T.text(\"6543210\"))\n  ),\n  test(\n    \"return value empty\",\n    B.foldRight<Nat, Text>(B.Buffer<Nat>(4), \"\", func(x, acc) = acc # Nat.toText(x)),\n    M.equals(T.text(\"\"))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i);\n};\n\nrun(suite(\"forAll\",\n[\n  test(\n    \"true\",\n    B.forAll<Nat>(buffer, func x = x >= 0),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"false\",\n    B.forAll<Nat>(buffer, func x = x % 2 == 0),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"default\",\n    B.forAll<Nat>(B.Buffer<Nat>(2), func _ = false),\n    M.equals(T.bool(true))\n  )\n]));\n\n/* --------------------------------------- */\nrun(suite(\"forSome\",\n[\n  test(\n    \"true\",\n    B.forSome<Nat>(buffer, func x = x % 2 == 0),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"false\",\n    B.forSome<Nat>(buffer, func x = x < 0),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"default\",\n    B.forSome<Nat>(B.Buffer<Nat>(2), func _ = false),\n    M.equals(T.bool(false))\n  )\n]));\n\n/* --------------------------------------- */\nrun(suite(\"forNone\",\n[\n  test(\n    \"true\",\n    B.forNone<Nat>(buffer, func x = x < 0),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"false\",\n    B.forNone<Nat>(buffer, func x = x % 2 != 0),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"default\",\n    B.forNone<Nat>(B.Buffer<Nat>(2), func _ = true),\n    M.equals(T.bool(true))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.make<Nat>(1);\n\nrun(suite(\"make\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [1]))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i)\n};\n\nrun(suite(\"contains\",\n[\n  test(\n    \"true\",\n    B.contains<Nat>(buffer, 2, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"true\",\n    B.contains<Nat>(buffer, 9, Nat.equal),\n    M.equals(T.bool(false))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nrun(suite(\"contains empty\",\n[\n  test(\n    \"true\",\n    B.contains<Nat>(buffer, 2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"true\",\n    B.contains<Nat>(buffer, 9, Nat.equal),\n    M.equals(T.bool(false))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(10);\nbuffer.add(1);\nbuffer.add(0);\nbuffer.add(3);\n\nrun(suite(\"max\",\n[\n  test(\n    \"return value\",\n    B.max<Nat>(buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, ?10))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(10);\nbuffer.add(1);\nbuffer.add(0);\nbuffer.add(3);\nbuffer.add(0);\n\nrun(suite(\"min\",\n[\n  test(\n    \"return value\",\n    B.min<Nat>(buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, ?0))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\nbuffer.add(2);\n\nrun(suite(\"isEmpty\",\n[\n  test(\n    \"true\",\n    B.isEmpty(B.Buffer<Nat>(2)),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"false\",\n    B.isEmpty(buffer),\n    M.equals(T.bool(false))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(10);\nbuffer.add(1);\nbuffer.add(0);\nbuffer.add(3);\nbuffer.add(0);\n\nB.removeDuplicates<Nat>(buffer, Nat.compare);\n\nrun(suite(\"removeDuplicates\",\n[\n  test(\n    \"elements (stable ordering)\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [2, 1, 10, 0, 3]))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nB.removeDuplicates<Nat>(buffer, Nat.compare);\n\nrun(suite(\"removeDuplicates empty\",\n[\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  )\n]));\n\n/* --------------------------------------- */\n\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(2);\n};\n\nB.removeDuplicates<Nat>(buffer, Nat.compare);\n\nrun(suite(\"removeDuplicates repeat singleton\",\n[\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [2]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nrun(suite(\"hash\",\n[\n  test(\n    \"empty buffer\",\n    Nat32.toNat(B.hash<Nat>(B.Buffer<Nat>(8), Hash.hash)),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"non-empty buffer\",\n    Nat32.toNat(B.hash<Nat>(buffer, Hash.hash)),\n    M.equals(T.nat(3365238326))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nrun(suite(\"toText\",\n[\n  test(\n    \"empty buffer\",\n    B.toText<Nat>(B.Buffer<Nat>(3), Nat.toText),\n    M.equals(T.text(\"[]\"))\n  ),\n  test(\n    \"singleton buffer\",\n    B.toText<Nat>(B.make<Nat>(3), Nat.toText),\n    M.equals(T.text(\"[3]\"))\n  ),\n  test(\n    \"non-empty buffer\",\n    B.toText<Nat>(buffer, Nat.toText),\n    M.equals(T.text(\"[0, 1, 2, 3, 4, 5]\"))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 2)) {\n  buffer.add(i);\n};\n\nrun(suite(\"equal\",\n[\n  test(\n    \"empty buffers\",\n    B.equal<Nat>(B.Buffer<Nat>(3), B.Buffer<Nat>(2), Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"non-empty buffers\",\n    B.equal<Nat>(buffer, B.clone(buffer), Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"non-empty and empty buffers\",\n    B.equal<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"non-empty buffers mismatching lengths\",\n    B.equal<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer2 := B.Buffer<Nat>(3);\n\nfor (i in Iter.range(0, 2)) {\n  buffer.add(i);\n};\n\nvar buffer3 = B.Buffer<Nat>(3);\n\nfor (i in Iter.range(2, 5)) {\n  buffer3.add(i);\n};\n\nrun(suite(\"compare\",\n[\n  test(\n    \"empty buffers\",\n    B.compare<Nat>(B.Buffer<Nat>(3), B.Buffer<Nat>(2), Nat.compare),\n    M.equals(OrderTestable(#equal))\n  ),\n  test(\n    \"non-empty buffers equal\",\n    B.compare<Nat>(buffer, B.clone(buffer), Nat.compare),\n    M.equals(OrderTestable(#equal))\n  ),\n  test(\n    \"non-empty and empty buffers\",\n    B.compare<Nat>(buffer, B.Buffer<Nat>(3), Nat.compare),\n    M.equals(OrderTestable(#greater))\n  ),\n  test(\n    \"non-empty buffers mismatching lengths\",\n    B.compare<Nat>(buffer, buffer2, Nat.compare),\n    M.equals(OrderTestable(#greater))\n  ),\n  test(\n    \"non-empty buffers lexicographic difference\",\n    B.compare<Nat>(buffer, buffer3, Nat.compare),\n    M.equals(OrderTestable(#less))\n  ),\n]));\n\n/* --------------------------------------- */\n\nvar nestedBuffer = B.Buffer<B.Buffer<Nat>>(3);\nfor (i in Iter.range(0, 4)) {\n  let innerBuffer = B.Buffer<Nat>(2);\n  for (j in if (i % 2 == 0) { Iter.range(0, 4) } else { Iter.range(0, 3) }) {\n    innerBuffer.add(j)\n  };\n  nestedBuffer.add(innerBuffer)\n};\nnestedBuffer.add(B.Buffer<Nat>(2));\n\nbuffer := B.flatten<Nat>(nestedBuffer);\n\nrun(suite(\"flatten\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(45))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 0, 1, 2, 3, 4]))\n  ),\n]));\n\n/* --------------------------------------- */\n\nnestedBuffer := B.Buffer<B.Buffer<Nat>>(3);\nfor (i in Iter.range(0, 4)) {\n  nestedBuffer.add(B.Buffer<Nat>(2));\n};\n\nbuffer := B.flatten<Nat>(nestedBuffer);\n\nrun(suite(\"flatten all empty inner buffers\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\n\nnestedBuffer := B.Buffer<B.Buffer<Nat>>(3);\nbuffer := B.flatten<Nat>(nestedBuffer);\n\nrun(suite(\"flatten empty outer buffer\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(0))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 7)) {\n  buffer.add(i);\n};\n\nbuffer2.clear();\n\nfor (i in Iter.range(0, 6)) {\n  buffer2.add(i);\n};\n\nbuffer3.clear();\n\nvar buffer4 = B.make<Nat>(3);\n\nB.reverse<Nat>(buffer);\nB.reverse<Nat>(buffer2);\nB.reverse<Nat>(buffer3);\nB.reverse<Nat>(buffer4);\n\nrun(suite(\"reverse\",\n[\n  test(\n    \"even elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [7, 6, 5, 4, 3, 2, 1, 0]))\n  ),\n  test(\n    \"odd elements\",\n    B.toArray(buffer2),\n    M.equals(T.array(T.natTestable, [6, 5, 4, 3, 2, 1, 0]))\n  ),\n  test(\n    \"empty\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"singleton\",\n    B.toArray(buffer4),\n    M.equals(T.array(T.natTestable, [3]))\n  ),\n]));\n\n\n/* --------------------------------------- */\n\nbuffer.clear();\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i)\n};\n\nvar partition = B.partition<Nat>(buffer, func x = x % 2 == 0);\nbuffer2 := partition.0;\nbuffer3 := partition.1;\n\nrun(suite(\"partition\",\n[\n  test(\n    \"capacity of true buffer\",\n    buffer2.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements of true buffer\",\n    B.toArray(buffer2),\n    M.equals(T.array(T.natTestable, [0, 2, 4]))\n  ),\n  test(\n    \"capacity of false buffer\",\n    buffer3.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements of false buffer\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [1, 3, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\n\nbuffer.clear();\nfor (i in Iter.range(0, 3)) {\n  buffer.add(i)\n};\n\nfor (i in Iter.range(10, 13)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\nfor (i in Iter.range(2, 5)) {\n  buffer2.add(i)\n};\nfor (i in Iter.range(13, 15)) {\n  buffer2.add(i)\n};\n\nbuffer := B.merge<Nat>(buffer, buffer2, Nat.compare);\n\nrun(suite(\"merge\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(23))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 2, 3, 3, 4, 5, 10, 11, 12, 13, 13, 14, 15]))\n  ),\n]));\n\n/* --------------------------------------- */\n\nbuffer.clear();\nfor (i in Iter.range(0, 3)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\n\nbuffer := B.merge<Nat>(buffer, buffer2, Nat.compare);\n\nrun(suite(\"merge with empty\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3]))\n  ),\n]));\n\n/* --------------------------------------- */\n\nbuffer.clear();\nbuffer2.clear();\n\nbuffer := B.merge<Nat>(buffer, buffer2, Nat.compare);\n\nrun(suite(\"merge two empty\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.add(0);\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(1);\nbuffer.add(5);\nbuffer.add(4);\n\nbuffer.sort(Nat.compare);\n\nrun(suite(\"sort even\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 1, 2, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.add(0);\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(1);\nbuffer.add(5);\n\nbuffer.sort(Nat.compare);\n\nrun(suite(\"sort odd\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 1, 2, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.sort(Nat.compare);\n\nrun(suite(\"sort empty\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer.add(2);\n\nbuffer.sort(Nat.compare);\n\nrun(suite(\"sort singleton\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [2] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\npartition := B.split<Nat>(buffer, 2);\nbuffer2 := partition.0;\nbuffer3 := partition.1;\n\nrun(suite(\"split\",\n[\n  test(\n    \"capacity prefix\",\n    buffer2.capacity(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"elements prefix\",\n    B.toArray(buffer2),\n    M.equals(T.array(T.natTestable, [0, 1]))\n  ),\n  test(\n    \"capacity suffix\",\n    buffer3.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements suffix\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\npartition := B.split<Nat>(buffer, 0);\nbuffer2 := partition.0;\nbuffer3 := partition.1;\n\nrun(suite(\"split at index 0\",\n[\n  test(\n    \"capacity prefix\",\n    buffer2.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements prefix\",\n    B.toArray(buffer2),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"capacity suffix\",\n    buffer3.capacity(),\n    M.equals(T.nat(9))\n  ),\n  test(\n    \"elements suffix\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\npartition := B.split<Nat>(buffer, 6);\nbuffer2 := partition.0;\nbuffer3 := partition.1;\n\nrun(suite(\"split at last index\",\n[\n  test(\n    \"capacity prefix\",\n    buffer2.capacity(),\n    M.equals(T.nat(9))\n  ),\n  test(\n    \"elements prefix\",\n    B.toArray(buffer2),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4, 5]))\n  ),\n  test(\n    \"capacity suffix\",\n    buffer3.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements suffix\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer2.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\nfor (i in Iter.range(0, 3)) {\n  buffer2.add(i);\n};\n\nvar bufferPairs = B.zip<Nat, Nat>(buffer, buffer2);\n\nrun(suite(\"zip\",\n[\n  test(\n    \"capacity\",\n    bufferPairs.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(bufferPairs),\n    M.equals(T.array(T.tuple2Testable(T.natTestable, T.natTestable), \n      [(0, 0), (1, 1), (2, 2), (3, 3)]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer2.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbufferPairs := B.zip<Nat, Nat>(buffer, buffer2);\n\nrun(suite(\"zip empty\",\n[\n  test(\n    \"capacity\",\n    bufferPairs.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(bufferPairs),\n    M.equals(T.array(T.tuple2Testable(T.natTestable, T.natTestable), \n      [] : [(Nat, Nat)]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer2.clear();\n\nbufferPairs := B.zip<Nat, Nat>(buffer, buffer2);\n\nrun(suite(\"zip both empty\",\n[\n  test(\n    \"capacity\",\n    bufferPairs.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(bufferPairs),\n    M.equals(T.array(T.tuple2Testable(T.natTestable, T.natTestable), \n      [] : [(Nat, Nat)]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer2.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\nfor (i in Iter.range(0, 3)) {\n  buffer2.add(i);\n};\n\nbuffer3 := B.zipWith<Nat, Nat, Nat>(buffer, buffer2, Nat.add);\n\nrun(suite(\"zipWith\",\n[\n  test(\n    \"capacity\",\n    buffer3.capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [0, 2, 4, 6]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\nbuffer2.clear();\n\nfor (i in Iter.range(0, 5)) {\n  buffer.add(i);\n};\n\nbuffer3 := B.zipWith<Nat, Nat, Nat>(buffer, buffer2, Nat.add);\n\nrun(suite(\"zipWithEmpty\",\n[\n  test(\n    \"capacity\",\n    buffer3.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer3),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 8)) {\n  buffer.add(i);\n};\n\nvar chunks = B.chunk<Nat>(buffer, 2);\n\nrun(suite(\"chunk\",\n[\n  test(\n    \"num chunks\",\n    chunks.size(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"chunk 0 capacity\",\n    chunks.get(0).capacity(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"chunk 0 elements\",\n    B.toArray(chunks.get(0)),\n    M.equals(T.array(T.natTestable, [0, 1]))\n  ),\n  test(\n    \"chunk 2 capacity\",\n    chunks.get(2).capacity(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"chunk 2 elements\",\n    B.toArray(chunks.get(2)),\n    M.equals(T.array(T.natTestable, [4, 5]))\n  ),\n  test(\n    \"chunk 4 capacity\",\n    chunks.get(4).capacity(),\n    M.equals(T.nat(3))\n  ),\n  test(\n    \"chunk 4 elements\",\n    B.toArray(chunks.get(4)),\n    M.equals(T.array(T.natTestable, [8]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nchunks := B.chunk<Nat>(buffer, 3);\n\nrun(suite(\"chunk empty\",\n[\n  test(\n    \"num chunks\",\n    chunks.size(),\n    M.equals(T.nat(0))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nchunks := B.chunk<Nat>(buffer, 10);\n\nrun(suite(\"chunk larger than buffer\",\n[\n  test(\n    \"num chunks\",\n    chunks.size(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"chunk 0 elements\",\n    B.toArray(chunks.get(0)),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.add(2);\nbuffer.add(2);\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(0);\nbuffer.add(0);\nbuffer.add(2);\nbuffer.add(1);\nbuffer.add(1);\n\nvar groups = B.groupBy<Nat>(buffer, Nat.equal);\n\nrun(suite(\"groupBy\",\n[\n  test(\n    \"num groups\",\n    groups.size(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"group 0 capacity\",\n    groups.get(0).capacity(),\n    M.equals(T.nat(9))\n  ),\n  test(\n    \"group 0 elements\",\n    B.toArray(groups.get(0)),\n    M.equals(T.array(T.natTestable, [2, 2, 2]))\n  ),\n  test(\n    \"group 1 capacity\",\n    groups.get(1).capacity(),\n    M.equals(T.nat(6))\n  ),\n  test(\n    \"group 1 elements\",\n    B.toArray(groups.get(1)),\n    M.equals(T.array(T.natTestable, [1]))\n  ),\n  test(\n    \"group 4 capacity\",\n    groups.get(4).capacity(),\n    M.equals(T.nat(2))\n  ),\n  test(\n    \"group 4 elements\",\n    B.toArray(groups.get(4)),\n    M.equals(T.array(T.natTestable, [1, 1]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\ngroups := B.groupBy<Nat>(buffer, Nat.equal);\n\nrun(suite(\"groupBy clear\",\n[\n  test(\n    \"num groups\",\n    groups.size(),\n    M.equals(T.nat(0))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(0)\n};\n\ngroups := B.groupBy<Nat>(buffer, Nat.equal);\n\nrun(suite(\"groupBy clear\",\n[\n  test(\n    \"num groups\",\n    groups.size(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"group 0 elements\",\n    B.toArray(groups.get(0)),\n    M.equals(T.array(T.natTestable, [0, 0, 0, 0, 0]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer := B.prefix<Nat>(buffer, 3);\n\nrun(suite(\"prefix\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 2]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer := B.prefix<Nat>(buffer, 0);\n\nrun(suite(\"prefix of empty\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(1))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer := B.prefix<Nat>(buffer, 5);\n\nrun(suite(\"trivial prefix\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(8))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\n\nfor (i in Iter.range(0, 2)) {\n  buffer2.add(i);\n};\n\nbuffer3.clear();\n\nbuffer3.add(2);\nbuffer3.add(1);\nbuffer3.add(0);\n\nrun(suite(\"isPrefixOf\",\n[\n  test(\n    \"normal prefix\",\n    B.isPrefixOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"identical buffers\",\n    B.isPrefixOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isPrefixOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not prefix\",\n    B.isPrefixOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not prefix from length\",\n    B.isPrefixOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not prefix of empty\",\n    B.isPrefixOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty prefix of empty\",\n    B.isPrefixOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(true))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\n\nfor (i in Iter.range(0, 2)) {\n  buffer2.add(i);\n};\n\nbuffer3.clear();\n\nbuffer3.add(2);\nbuffer3.add(1);\nbuffer3.add(0);\n\nrun(suite(\"isStrictPrefixOf\",\n[\n  test(\n    \"normal prefix\",\n    B.isStrictPrefixOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"identical buffers\",\n    B.isStrictPrefixOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isStrictPrefixOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not prefix\",\n    B.isStrictPrefixOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not prefix from length\",\n    B.isStrictPrefixOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not prefix of empty\",\n    B.isStrictPrefixOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty prefix of empty\",\n    B.isStrictPrefixOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer := B.subBuffer<Nat>(buffer, 1, 3);\n\nrun(suite(\"subBuffer\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [1, 2, 3]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nrun(suite(\"subBuffer edge cases\",\n[\n  test(\n    \"prefix\",\n    B.prefix(buffer, 3),\n    M.equals({ {item = B.subBuffer(buffer, 0, 3)} and NatBufferTestable})\n  ),\n  test(\n    \"suffix\",\n    B.suffix(buffer, 3),\n    M.equals({ {item = B.subBuffer(buffer, 2, 3)} and NatBufferTestable})\n  ),\n  test(\n    \"empty\",\n    B.toArray(B.subBuffer(buffer, 2, 0)),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"trivial\",\n    B.subBuffer(buffer, 0, buffer.size()),\n    M.equals({ {item = buffer} and NatBufferTestable})\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\n\nfor (i in Iter.range(0, 2)) {\n  buffer2.add(i);\n};\n\nbuffer3.clear();\n\nfor (i in Iter.range(1, 3)) {\n  buffer3.add(i);\n};\n\nrun(suite(\"isSubBufferOf\",\n[\n  test(\n    \"normal subBuffer\",\n    B.isSubBufferOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"prefix\",\n    B.isSubBufferOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"identical buffers\",\n    B.isSubBufferOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isSubBufferOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not subBuffer\",\n    B.isSubBufferOf<Nat>(buffer3, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not subBuffer from length\",\n    B.isSubBufferOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not subBuffer of empty\",\n    B.isSubBufferOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty subBuffer of empty\",\n    B.isSubBufferOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(true))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\n\nfor (i in Iter.range(0, 2)) {\n  buffer2.add(i);\n};\n\nbuffer3.clear();\n\nfor (i in Iter.range(1, 3)) {\n  buffer3.add(i);\n};\n\nbuffer4 := B.Buffer<Nat>(4);\n\nfor (i in Iter.range(3, 4)) {\n  buffer4.add(i);\n};\n\nrun(suite(\"isStrictSubBufferOf\",\n[\n  test(\n    \"normal strict subBuffer\",\n    B.isStrictSubBufferOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"prefix\",\n    B.isStrictSubBufferOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"suffix\",\n    B.isStrictSubBufferOf<Nat>(buffer4, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"identical buffers\",\n    B.isStrictSubBufferOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isStrictSubBufferOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not subBuffer\",\n    B.isStrictSubBufferOf<Nat>(buffer3, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not subBuffer from length\",\n    B.isStrictSubBufferOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not subBuffer of empty\",\n    B.isStrictSubBufferOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty not strict subBuffer of empty\",\n    B.isStrictSubBufferOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer := B.suffix<Nat>(buffer, 3);\n\nrun(suite(\"suffix\",\n[\n  test(\n    \"capacity\",\n    buffer.capacity(),\n    M.equals(T.nat(5))\n  ),\n  test(\n    \"elements\",\n    B.toArray(buffer),\n    M.equals(T.array(T.natTestable, [2, 3, 4]))\n  )\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nrun(suite(\"suffix edge cases\",\n[\n  test(\n    \"empty\",\n    B.toArray(B.prefix(buffer, 0)),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"trivial\",\n    B.prefix(buffer, buffer.size()),\n    M.equals({ {item = buffer} and NatBufferTestable})\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\nfor (i in Iter.range(3, 4)) {\n  buffer2.add(i)\n};\n\nbuffer3.clear();\n\nbuffer3.add(2);\nbuffer3.add(1);\nbuffer3.add(0);\n\nrun(suite(\"isSuffixOf\",\n[\n  test(\n    \"normal suffix\",\n    B.isSuffixOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"identical buffers\",\n    B.isSuffixOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isSuffixOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not suffix\",\n    B.isSuffixOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not suffix from length\",\n    B.isSuffixOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not suffix of empty\",\n    B.isSuffixOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty suffix of empty\",\n    B.isSuffixOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(true))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nbuffer2.clear();\nfor (i in Iter.range(3, 4)) {\n  buffer2.add(i)\n};\n\nbuffer3.clear();\n\nbuffer3.add(2);\nbuffer3.add(1);\nbuffer3.add(0);\n\nrun(suite(\"isStrictSuffixOf\",\n[\n  test(\n    \"normal suffix\",\n    B.isStrictSuffixOf<Nat>(buffer2, buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"identical buffers\",\n    B.isStrictSuffixOf<Nat>(buffer, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"one empty buffer\",\n    B.isStrictSuffixOf<Nat>(B.Buffer<Nat>(3), buffer, Nat.equal),\n    M.equals(T.bool(true))\n  ),\n  test(\n    \"not suffix\",\n    B.isStrictSuffixOf<Nat>(buffer3, buffer, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not suffix from length\",\n    B.isStrictSuffixOf<Nat>(buffer, buffer2, Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"not suffix of empty\",\n    B.isStrictSuffixOf<Nat>(buffer, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n  test(\n    \"empty suffix of empty\",\n    B.isStrictSuffixOf<Nat>(B.Buffer<Nat>(4), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.bool(false))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nrun(suite(\"takeWhile\",\n[\n  test(\n    \"normal case\",\n    B.toArray(B.takeWhile<Nat>(buffer, func x = x < 3)),\n    M.equals(T.array(T.natTestable, [0, 1, 2]))\n  ),\n  test(\n    \"empty\",\n    B.toArray(B.takeWhile<Nat>(B.Buffer<Nat>(3), func x = x < 3)),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 4)) {\n  buffer.add(i)\n};\n\nrun(suite(\"dropWhile\",\n[\n  test(\n    \"normal case\",\n    B.toArray(B.dropWhile<Nat>(buffer, func x = x < 3)),\n    M.equals(T.array(T.natTestable, [3, 4]))\n  ),\n  test(\n    \"empty\",\n    B.toArray(B.dropWhile<Nat>(B.Buffer<Nat>(3), func x = x < 3)),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"drop all\",\n    B.toArray(B.dropWhile<Nat>(buffer, func _ = true)),\n    M.equals(T.array(T.natTestable, [] : [Nat]))\n  ),\n  test(\n    \"drop none\",\n    B.toArray(B.dropWhile<Nat>(buffer, func _ = false)),\n    M.equals(T.array(T.natTestable, [0, 1, 2, 3, 4]))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(1, 6)) {\n  buffer.add(i)\n};\n\nrun(suite(\"binarySearch\",\n[\n  test(\n    \"find in middle\",\n    B.binarySearch<Nat>(2, buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, ?1))\n  ),\n  test(\n    \"find first\",\n    B.binarySearch<Nat>(1, buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, ?0))\n  ),\n  test(\n    \"find last\",\n    B.binarySearch<Nat>(6, buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, ?5))\n  ),\n  test(\n    \"not found to the right\",\n    B.binarySearch<Nat>(10, buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"not found to the left\",\n    B.binarySearch<Nat>(0, buffer, Nat.compare),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nfor (i in Iter.range(0, 6)) {\n  buffer.add(i)\n};\n\nrun(suite(\"indexOf\",\n[\n  test(\n    \"find in middle\",\n    B.indexOf<Nat>(2, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?2))\n  ),\n  test(\n    \"find first\",\n    B.indexOf<Nat>(0, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?0))\n  ),\n  test(\n    \"find last\",\n    B.indexOf<Nat>(6, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?6))\n  ),\n  test(\n    \"not found\",\n    B.indexOf<Nat>(10, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"empty\",\n    B.indexOf<Nat>(100, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.add(2); // 0\nbuffer.add(2); // 1\nbuffer.add(1); // 2\nbuffer.add(10);// 3\nbuffer.add(1); // 4\nbuffer.add(0); // 5\nbuffer.add(10);// 6\nbuffer.add(3); // 7\nbuffer.add(0); // 8\n\nrun(suite(\"lastIndexOf\",\n[\n  test(\n    \"find in middle\",\n    B.lastIndexOf<Nat>(10, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?6))\n  ),\n  test(\n    \"find only\",\n    B.lastIndexOf<Nat>(3, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?7))\n  ),\n  test(\n    \"find last\",\n    B.lastIndexOf<Nat>(0, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?8))\n  ),\n  test(\n    \"not found\",\n    B.lastIndexOf<Nat>(100, buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"empty\",\n    B.lastIndexOf<Nat>(100, B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n]));\n\n/* --------------------------------------- */\nbuffer.clear();\n\nbuffer.add(2); // 0\nbuffer.add(2); // 1\nbuffer.add(1); // 2\nbuffer.add(10);// 3\nbuffer.add(1); // 4\nbuffer.add(10);// 5\nbuffer.add(3); // 6\nbuffer.add(0); // 7\n\nrun(suite(\"indexOfBuffer\",\n[\n  test(\n    \"find in middle\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([1, 10, 1]), buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?2))\n  ),\n  test(\n    \"find first\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([2, 2, 1, 10]), buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?0))\n  ),\n  test(\n    \"find last\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([0]), buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, ?7))\n  ),\n  test(\n    \"not found\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([99, 100, 1]), buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"search for empty buffer\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([]), buffer, Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"search through empty buffer\",\n    B.indexOfBuffer<Nat>(B.fromArray<Nat>([1, 2, 3]), B.Buffer<Nat>(2), Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n  test(\n    \"search for empty in empty\",\n    B.indexOfBuffer<Nat>(B.Buffer<Nat>(2), B.Buffer<Nat>(3), Nat.equal),\n    M.equals(T.optional(T.natTestable, null : ?Nat))\n  ),\n]));\n"},"int8Test.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Int8 \"mo:base/Int8\";\n\nassert (Int8.fromIntWrap(256) == (0:Int8));\nassert (Int8.fromIntWrap(-256) == (0:Int8));\nassert (Int8.fromIntWrap(128) == (-128:Int8));\nassert (Int8.fromIntWrap(255) == (-1:Int8));\n"},"trieTest.mo":{"content":"import Trie \"mo:base/Trie\";\nimport Nat \"mo:base/Nat\";\nimport Option \"mo:base/Option\";\nimport Iter \"mo:base/Iter\";\nimport Text \"mo:base/Text\";\nimport Debug \"mo:base/Debug\";\n\ndebug {\n  type Trie<K, V> = Trie.Trie<K, V>;\n  type Key<K> = Trie.Key<K>;\n\n  func key(i: Nat) : Key<Text> {\n    let t = Nat.toText i;\n    { key = t ; hash = Text.hash t }\n  };\n\n  let max = 100;\n\n  // put k-v elements, one by one (but hashes are expected random).\n  Debug.print \"Trie.put\";\n  var t : Trie<Text, Nat> = Trie.empty();\n  for (i in Iter.range(0, max - 1)) {\n    let (t1_, x) = Trie.put<Text, Nat>(t, key i, Text.equal, i);\n    assert (Option.isNull(x));\n    assert Trie.isValid(t1_, false);\n    t := t1_;\n  };\n  assert Trie.size(t) == max;\n\n  // remove all elements, one by one (but hashes are expected random).\n  do {\n    Debug.print \"Trie.remove\";\n    var t1 = t;\n    for (i in Iter.range(0, max - 1)) {\n      let (t1_, x) = Trie.remove<Text, Nat>(t1, key i, Text.equal);\n      assert Trie.isValid(t1_, false);\n      assert (Option.isSome(x));\n      t1 := t1_;\n    }\n  };\n\n  // filter all elements away, one by one (but hashes are expected random).\n  do {\n    Debug.print \"Trie.filter\";\n    var t1 = t;\n    for (i in Iter.range(0, max - 1)) {\n      t1 := Trie.filter (t1, func (t : Text, n : Nat) : Bool { n != i } );\n      assert Trie.isValid(t1, false);\n      assert Trie.size(t1) == (max - (i + 1) : Nat);\n    }\n  };\n\n  // filter-map all elements away, one by one (but hashes are expected random).\n  do {\n    Debug.print \"Trie.mapFilter\";\n    var t1 = t;\n    for (i in Iter.range(0, max - 1)) {\n      t1 := Trie.mapFilter (t1,\n       func (t : Text, n : Nat) : ?Nat {\n         if (n != i) ?n else null }\n      );\n      assert Trie.isValid(t1, false);\n      assert Trie.size(t1) == (max - (i + 1) : Nat);\n    }\n  }\n};\n"},"orderTest.mo":{"content":"import Order \"mo:base/Order\";\nimport Debug \"mo:base/Debug\";\n\nDebug.print(\"Order\");\n\ndo {\n  Debug.print(\"  isLess\");\n\n  assert(Order.isLess(#less));\n  assert(not Order.isLess(#equal));\n  assert(not Order.isLess(#greater));\n};\n\ndo {\n  Debug.print(\"  isEqual\");\n\n  assert(not Order.isEqual(#less));\n  assert(Order.isEqual(#equal));\n  assert(not Order.isEqual(#greater));\n};\n\ndo {\n  Debug.print(\"  isGreater\");\n\n  assert(not Order.isGreater(#less));\n  assert(not Order.isGreater(#equal));\n  assert(Order.isGreater(#greater));\n};\n"},"natTest.mo":{"content":"import Debug \"mo:base/Debug\";\nimport Nat \"mo:base/Nat\";\n\nDebug.print(\"Nat\");\n\ndo {\n  Debug.print(\"  add\");\n\n  assert(Nat.add(1, Nat.add(2, 3)) == Nat.add(1, Nat.add(2, 3)));\n  assert(Nat.add(0, 1) == 1);\n  assert(1 == Nat.add(1, 0));\n  assert(Nat.add(0, 1) == Nat.add(1, 0));\n  assert(Nat.add(1, 2) == Nat.add(2, 1));\n};\n\ndo {\n  Debug.print(\"  toText\");\n\n  assert(Nat.toText(0) == \"0\");\n  assert(Nat.toText(1234) == \"1234\");\n};\n"}}}